
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Vidkin/gophkeeper/app/cmd/auth.go (33.3%)</option>
				
				<option value="file1">github.com/Vidkin/gophkeeper/app/cmd/cards.go (41.4%)</option>
				
				<option value="file2">github.com/Vidkin/gophkeeper/app/cmd/credentials.go (37.0%)</option>
				
				<option value="file3">github.com/Vidkin/gophkeeper/app/cmd/files.go (33.3%)</option>
				
				<option value="file4">github.com/Vidkin/gophkeeper/app/cmd/notes.go (34.6%)</option>
				
				<option value="file5">github.com/Vidkin/gophkeeper/app/cmd/register.go (33.3%)</option>
				
				<option value="file6">github.com/Vidkin/gophkeeper/app/cmd/root.go (73.1%)</option>
				
				<option value="file7">github.com/Vidkin/gophkeeper/app/server.go (0.0%)</option>
				
				<option value="file8">github.com/Vidkin/gophkeeper/cmd/client/main.go (0.0%)</option>
				
				<option value="file9">github.com/Vidkin/gophkeeper/cmd/server/main.go (0.0%)</option>
				
				<option value="file10">github.com/Vidkin/gophkeeper/internal/client/auth.go (0.0%)</option>
				
				<option value="file11">github.com/Vidkin/gophkeeper/internal/client/cards.go (0.0%)</option>
				
				<option value="file12">github.com/Vidkin/gophkeeper/internal/client/client.go (0.0%)</option>
				
				<option value="file13">github.com/Vidkin/gophkeeper/internal/client/credentials.go (0.0%)</option>
				
				<option value="file14">github.com/Vidkin/gophkeeper/internal/client/files.go (0.0%)</option>
				
				<option value="file15">github.com/Vidkin/gophkeeper/internal/client/notes.go (0.0%)</option>
				
				<option value="file16">github.com/Vidkin/gophkeeper/internal/client/register.go (0.0%)</option>
				
				<option value="file17">github.com/Vidkin/gophkeeper/internal/config/interval.go (83.3%)</option>
				
				<option value="file18">github.com/Vidkin/gophkeeper/internal/config/server.go (0.0%)</option>
				
				<option value="file19">github.com/Vidkin/gophkeeper/internal/config/server_address.go (100.0%)</option>
				
				<option value="file20">github.com/Vidkin/gophkeeper/internal/handlers/bank_cards_add.go (0.0%)</option>
				
				<option value="file21">github.com/Vidkin/gophkeeper/internal/handlers/bank_cards_get.go (0.0%)</option>
				
				<option value="file22">github.com/Vidkin/gophkeeper/internal/handlers/bank_cards_get_one.go (0.0%)</option>
				
				<option value="file23">github.com/Vidkin/gophkeeper/internal/handlers/bank_cards_remove.go (0.0%)</option>
				
				<option value="file24">github.com/Vidkin/gophkeeper/internal/handlers/echo.go (0.0%)</option>
				
				<option value="file25">github.com/Vidkin/gophkeeper/internal/handlers/files_download.go (0.0%)</option>
				
				<option value="file26">github.com/Vidkin/gophkeeper/internal/handlers/files_get.go (0.0%)</option>
				
				<option value="file27">github.com/Vidkin/gophkeeper/internal/handlers/files_remove.go (0.0%)</option>
				
				<option value="file28">github.com/Vidkin/gophkeeper/internal/handlers/files_upload.go (0.0%)</option>
				
				<option value="file29">github.com/Vidkin/gophkeeper/internal/handlers/note_remove.go (0.0%)</option>
				
				<option value="file30">github.com/Vidkin/gophkeeper/internal/handlers/notes_add.go (0.0%)</option>
				
				<option value="file31">github.com/Vidkin/gophkeeper/internal/handlers/notes_get.go (0.0%)</option>
				
				<option value="file32">github.com/Vidkin/gophkeeper/internal/handlers/notes_get_one.go (0.0%)</option>
				
				<option value="file33">github.com/Vidkin/gophkeeper/internal/handlers/user_authorize.go (0.0%)</option>
				
				<option value="file34">github.com/Vidkin/gophkeeper/internal/handlers/user_credentials_add.go (0.0%)</option>
				
				<option value="file35">github.com/Vidkin/gophkeeper/internal/handlers/user_credentials_get.go (0.0%)</option>
				
				<option value="file36">github.com/Vidkin/gophkeeper/internal/handlers/user_credentials_get_one.go (0.0%)</option>
				
				<option value="file37">github.com/Vidkin/gophkeeper/internal/handlers/user_credentials_remove.go (0.0%)</option>
				
				<option value="file38">github.com/Vidkin/gophkeeper/internal/handlers/user_register.go (0.0%)</option>
				
				<option value="file39">github.com/Vidkin/gophkeeper/internal/logger/logger.go (0.0%)</option>
				
				<option value="file40">github.com/Vidkin/gophkeeper/internal/storage/minio.go (71.4%)</option>
				
				<option value="file41">github.com/Vidkin/gophkeeper/internal/storage/postgres.go (79.2%)</option>
				
				<option value="file42">github.com/Vidkin/gophkeeper/pkg/aes/decrypt.go (82.4%)</option>
				
				<option value="file43">github.com/Vidkin/gophkeeper/pkg/aes/encrypt.go (81.8%)</option>
				
				<option value="file44">github.com/Vidkin/gophkeeper/pkg/cert/x509.go (83.9%)</option>
				
				<option value="file45">github.com/Vidkin/gophkeeper/pkg/hash/sha256.go (100.0%)</option>
				
				<option value="file46">github.com/Vidkin/gophkeeper/pkg/interceptors/hash.go (80.8%)</option>
				
				<option value="file47">github.com/Vidkin/gophkeeper/pkg/interceptors/logging.go (100.0%)</option>
				
				<option value="file48">github.com/Vidkin/gophkeeper/pkg/interceptors/validate_token.go (80.8%)</option>
				
				<option value="file49">github.com/Vidkin/gophkeeper/pkg/jwt/jwt.go (80.0%)</option>
				
				<option value="file50">github.com/Vidkin/gophkeeper/proto/gophkeeper.pb.go (2.5%)</option>
				
				<option value="file51">github.com/Vidkin/gophkeeper/proto/gophkeeper_grpc.pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright © 2024 MIKHAIL SIRKIN &lt;skim991@gmail.com&gt;
*/
package cmd

import (
        "fmt"

        "github.com/spf13/cobra"

        "github.com/Vidkin/gophkeeper/internal/client"
)

// authCmd represents the authorize command
var authCmd = &amp;cobra.Command{
        Use:   "auth [login] [password]",
        Short: "Authorize user",
        Long: `Authorize user in GophKeeper and get JWT. For example:
        client auth login password`,
        Args: cobra.ExactArgs(2),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.Auth(args[0], args[1]); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(authCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright © 2024 MIKHAIL SIRKIN &lt;skim991@gmail.com&gt;
*/
package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"

        "github.com/Vidkin/gophkeeper/internal/client"
        "github.com/Vidkin/gophkeeper/proto"
)

var (
        cardID int64
        card   proto.BankCard
)

// cardsCmd represents the bank cards management command
var cardsCmd = &amp;cobra.Command{
        Use:   "cards [command] [flags]",
        Short: "Bank cards management",
        Long: `Bank cards management in GophKeeper. For example:
        - client cards get cardID
        - client cards getAll
        - client cards add cardInfo
        - client cards remove cardID`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                err := cmd.Help()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var addCardCmd = &amp;cobra.Command{
        Use:   "add [flags]",
        Short: "Add a new bank card to GophKeeper",
        Long: `This command allows you to add a new bank card to your account in GophKeeper. For example:
        - client cards add --owner "Name Surname" --cvv 123 --expire 2024-12-26 --number 78878877 --desc "Test card"`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.AddCard(&amp;card); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var getCardCmd = &amp;cobra.Command{
        Use:   "get [flags]",
        Short: "Get bank card by ID from GophKeeper",
        Long: `This command allows you to get bank card info by ID from your account in GophKeeper. For example:
        - client cards get --id 9`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if cardID &lt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a bank card ID")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := client.GetCard(cardID); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var removeCardCmd = &amp;cobra.Command{
        Use:   "remove [flags]",
        Short: "Remove bank card by ID from GophKeeper",
        Long: `This command allows you to remove bank card info by ID from your account in GophKeeper. For example:
        - client cards remove --id 9`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if cardID &lt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a bank card ID")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := client.RemoveCard(cardID); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var getAllCardsCmd = &amp;cobra.Command{
        Use:   "getAll",
        Short: "Get all bank cards from GophKeeper",
        Long: `This command allows you to get all bank cards from your account in GophKeeper. For example:
        - client cards getAll`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.GetAllCards(); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        addCardCmd.PersistentFlags().StringVar(&amp;card.Owner, "owner", "", "bank card owner")
        addCardCmd.PersistentFlags().StringVar(&amp;card.Cvv, "cvv", "", "bank card CVV")
        addCardCmd.PersistentFlags().StringVar(&amp;card.ExpireDate, "expire", "", "bank card expire date")
        addCardCmd.PersistentFlags().StringVar(&amp;card.Number, "number", "", "bank card number")
        addCardCmd.PersistentFlags().StringVar(&amp;card.Description, "desc", "", "bank card description")

        getCardCmd.PersistentFlags().Int64Var(&amp;cardID, "id", -1, "bank card id")

        removeCardCmd.PersistentFlags().Int64Var(&amp;cardID, "id", -1, "bank card id")

        cardsCmd.AddCommand(getCardCmd)
        cardsCmd.AddCommand(removeCardCmd)
        cardsCmd.AddCommand(addCardCmd)
        cardsCmd.AddCommand(getAllCardsCmd)
        rootCmd.AddCommand(cardsCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright © 2024 MIKHAIL SIRKIN &lt;skim991@gmail.com&gt;
*/
package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"

        "github.com/Vidkin/gophkeeper/internal/client"
        "github.com/Vidkin/gophkeeper/proto"
)

var (
        credID      int64
        credentials proto.Credentials
)

// credentialsCmd represents the user credentials management command
var credentialsCmd = &amp;cobra.Command{
        Use:   "credentials [command] [flags]",
        Short: "User credentials management",
        Long: `User credentials management in GophKeeper. For example:
        - client credentials get credID
        - client credentials getAll
        - client credentials add credentials info
        - client credentials remove credID`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                err := cmd.Help()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var addCredentialCmd = &amp;cobra.Command{
        Use:   "add [flags]",
        Short: "Add a new user credentials to GophKeeper",
        Long: `This command allows you to add a new user credentials to your account in GophKeeper. For example:
        - client credentials add --login Login --pass Password --desc Description`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.AddCredentials(&amp;credentials); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var getCredentialsCmd = &amp;cobra.Command{
        Use:   "get [flags]",
        Short: "Get user credentials by ID from GophKeeper",
        Long: `This command allows you to get user credentials by ID from your account in GophKeeper. For example:
        - client credentials get --id 9`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if credID &lt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a credential ID")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := client.GetCredentials(credID); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var removeCredentialsCmd = &amp;cobra.Command{
        Use:   "remove [flags]",
        Short: "Remove user credentials by ID from GophKeeper",
        Long: `This command allows you to remove user credentials info by ID from your account in GophKeeper. For example:
        - client credentials remove --id 9`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if credID &lt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a credential ID")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := client.RemoveCredentials(credID); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var getAllCredentialsCmd = &amp;cobra.Command{
        Use:   "getAll",
        Short: "Get all user credentials from GophKeeper",
        Long: `This command allows you to get all user credentials from your account in GophKeeper. For example:
        - client credentials getAll`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.GetAllCredentials(); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        addCredentialCmd.PersistentFlags().StringVar(&amp;credentials.Login, "login", "", "login")
        addCredentialCmd.PersistentFlags().StringVar(&amp;credentials.Password, "pass", "", "password")
        addCredentialCmd.PersistentFlags().StringVar(&amp;credentials.Description, "desc", "", "credentials description")

        getCredentialsCmd.PersistentFlags().Int64Var(&amp;credID, "id", -1, "credentials id")
        removeCredentialsCmd.PersistentFlags().Int64Var(&amp;credID, "id", -1, "credentials id")

        credentialsCmd.AddCommand(getCredentialsCmd)
        credentialsCmd.AddCommand(removeCredentialsCmd)
        credentialsCmd.AddCommand(addCredentialCmd)
        credentialsCmd.AddCommand(getAllCredentialsCmd)
        rootCmd.AddCommand(credentialsCmd)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright © 2024 MIKHAIL SIRKIN &lt;skim991@gmail.com&gt;
*/
package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"

        "github.com/Vidkin/gophkeeper/internal/client"
)

var (
        filePath    string
        fileName    string
        description string
)

// filesCmd represents the files management command
var filesCmd = &amp;cobra.Command{
        Use:   "files [command] [flags]",
        Short: "Files management",
        Long: `Files management in GophKeeper. For example:
        - client files download --id fileID --path /path/to/file
        - client files upload --path /path/to/file --desc "File description"
        - client files getAll
        - client files remove fileID`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                err := cmd.Help()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var downloadCmd = &amp;cobra.Command{
        Use:   "download [flags]",
        Short: "Download file from GophKeeper",
        Long: `This command allows you to download file from your account in GophKeeper. For example:
        - client files download --name FileName --dir /path/to/file`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if fileName == "" || filePath == "" </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a correct file name and dir")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := client.DownloadFile(fileName, filePath); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var uploadCmd = &amp;cobra.Command{
        Use:   "upload [flags]",
        Short: "Upload file to GophKeeper",
        Long: `This command allows you to upload file to your account in GophKeeper. For example:
        - client files upload --path /path/to/file --desc "File description" --text "Text for text files"`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if filePath == "" </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a source file path")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if err := client.UploadFile(filePath, description); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var removeCmd = &amp;cobra.Command{
        Use:   "remove [flags]",
        Short: "Remove file by name from GophKeeper",
        Long: `This command allows you to remove file by name from your account in GophKeeper. For example:
        - client files remove --name FileName`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if fileName == "" </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a file name")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := client.RemoveFile(fileName); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var getAllCmd = &amp;cobra.Command{
        Use:   "getAll",
        Short: "Get all files infos from GophKeeper",
        Long: `This command allows you to get all files infos from your account in GophKeeper. For example:
        - client files getAll`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.GetAllFiles(); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        downloadCmd.PersistentFlags().StringVar(&amp;fileName, "name", "", "file name to download")
        downloadCmd.PersistentFlags().StringVar(&amp;filePath, "dir", "", "dir where to download file")

        uploadCmd.PersistentFlags().StringVar(&amp;filePath, "path", "", "path to source file")
        uploadCmd.PersistentFlags().StringVar(&amp;description, "desc", "", "file description")

        removeCmd.PersistentFlags().StringVar(&amp;fileName, "name", "", "file name to remove")

        filesCmd.AddCommand(downloadCmd)
        filesCmd.AddCommand(uploadCmd)
        filesCmd.AddCommand(removeCmd)
        filesCmd.AddCommand(getAllCmd)
        rootCmd.AddCommand(filesCmd)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright © 2024 MIKHAIL SIRKIN &lt;skim991@gmail.com&gt;
*/
package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"

        "github.com/Vidkin/gophkeeper/internal/client"
        "github.com/Vidkin/gophkeeper/proto"
)

var (
        noteID int64
        note   proto.Note
)

// notesCmd represents the user notes management command
var notesCmd = &amp;cobra.Command{
        Use:   "notes [command] [flags]",
        Short: "User notes management",
        Long: `User notes management in GophKeeper. For example:
        - client notes get noteID
        - client notes getAll
        - client notes add note info
        - client notes remove noteID`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                err := cmd.Help()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var addNoteCmd = &amp;cobra.Command{
        Use:   "add [flags]",
        Short: "Add a new user note to GophKeeper",
        Long: `This command allows you to add a new user note to your account in GophKeeper. For example:
        - client notes add --text NoteText --desc Description`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.AddNote(&amp;note); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var getNoteCmd = &amp;cobra.Command{
        Use:   "get [flags]",
        Short: "Get user note by ID from GophKeeper",
        Long: `This command allows you to get user note by ID from your account in GophKeeper. For example:
        - client notes get --id 9`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if noteID &lt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a note ID")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := client.GetNote(noteID); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var removeNoteCmd = &amp;cobra.Command{
        Use:   "remove [flags]",
        Short: "Remove user note by ID from GophKeeper",
        Long: `This command allows you to remove user note by ID from your account in GophKeeper. For example:
        - client notes remove --id 9`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if noteID &lt; 0 </span><span class="cov0" title="0">{
                        fmt.Println("You must provide a note ID")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">if err := client.RemoveNote(noteID); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

var getAllNotesCmd = &amp;cobra.Command{
        Use:   "getAll",
        Short: "Get all user notes from GophKeeper",
        Long: `This command allows you to get all user notes from your account in GophKeeper. For example:
        - client notes getAll`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.GetAllNotes(); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        addNoteCmd.PersistentFlags().StringVar(&amp;note.Text, "text", "", "text")
        addNoteCmd.PersistentFlags().StringVar(&amp;note.Description, "desc", "", "note description")

        getNoteCmd.PersistentFlags().Int64Var(&amp;noteID, "id", -1, "note id")

        removeNoteCmd.PersistentFlags().Int64Var(&amp;noteID, "id", -1, "note id")

        notesCmd.AddCommand(getNoteCmd)
        notesCmd.AddCommand(removeNoteCmd)
        notesCmd.AddCommand(addNoteCmd)
        notesCmd.AddCommand(getAllNotesCmd)
        rootCmd.AddCommand(notesCmd)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright © 2024 MIKHAIL SIRKIN &lt;skim991@gmail.com&gt;
*/
package cmd

import (
        "fmt"

        "github.com/spf13/cobra"

        "github.com/Vidkin/gophkeeper/internal/client"
)

// registerCmd represents the register command
var registerCmd = &amp;cobra.Command{
        Use:   "register [login] [password]",
        Short: "Register user",
        Long: `Register user in GophKeeper. For example:
        client register login password`,
        Args: cobra.ExactArgs(2),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if err := client.Register(args[0], args[1]); err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(registerCmd)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright © 2024 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        cfgFilePath string
        hashKey     string
        secretKey   string
)

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)
        rootCmd.PersistentFlags().StringVar(&amp;cfgFilePath, "config", "", "client config file")
        rootCmd.PersistentFlags().StringVar(&amp;hashKey, "hash_key", "", "key for calculate request data hash")
        rootCmd.PersistentFlags().StringVar(&amp;secretKey, "secret_key", "", "key to encrypt data in database")
}</span>

func initConfig() <span class="cov8" title="1">{
        if cfgFilePath != "" </span><span class="cov8" title="1">{
                viper.SetConfigFile(cfgFilePath)
                if err := viper.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                        fmt.Println("Can't read config:", err)
                        panic("Can't read config")</span>
                }
        } else<span class="cov8" title="1"> {
                fmt.Println("You must provide the path to config file")
                panic("You must provide the path to config file")</span>
        }
        <span class="cov8" title="1">if hashKey != "" </span><span class="cov8" title="1">{
                if err := viper.BindPFlag("hash_key", rootCmd.PersistentFlags().Lookup("hash_key")); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Can't bind hash key flag to viper: ", err)
                        panic("Can't bind hash key flag to viper")</span>
                }
        } else<span class="cov8" title="1"> {
                fmt.Println("You must provide the hash_key flag, see --help")
                panic("You must provide the hash_key flag, see --help")</span>
        }

        <span class="cov8" title="1">if secretKey != "" </span><span class="cov8" title="1">{
                if err := viper.BindPFlag("secret_key", rootCmd.PersistentFlags().Lookup("secret_key")); err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Can't bind secret key flag to viper: ", err)
                        panic("Can't bind secret key flag to viper")</span>
                }
        } else<span class="cov8" title="1"> {
                fmt.Println("You must provide the secret_key flag, see --help")
                panic("You must provide the secret_key flag, see --help")</span>
        }
}

var rootCmd = &amp;cobra.Command{
        Use:   "client",
        Short: "GophKeeper client application",
        Long:  ``,
        Run: func(cmd *cobra.Command, args []string) {<span class="cov0" title="0">
        }</span>,
}

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package app provides an implementation of a GophKeeper gRPC server application.
// It encapsulates all necessary components for running the server, including configuration,
// gRPC server instance, listener, and storage. The package handles signal management to
// gracefully stop the server and ensures proper resource cleanup.
package app

import (
        "crypto/tls"
        "net"
        "os"
        "os/signal"
        "syscall"

        "go.uber.org/zap"
        "google.golang.org/grpc"

        "github.com/Vidkin/gophkeeper/internal/config"
        "github.com/Vidkin/gophkeeper/internal/handlers"
        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/internal/storage"
        "github.com/Vidkin/gophkeeper/pkg/interceptors"
        "github.com/Vidkin/gophkeeper/proto"
)

// ServerApp represents the gRPC server application, encapsulating all necessary components
// for running the server, including configuration, gRPC server instance, listener, and storage.
//
// This struct is responsible for initializing and managing the lifecycle of the gRPC server,
// handling signals to gracefully stop the server, and managing storage connections.
type ServerApp struct {
        config     *config.ServerConfig
        gRPCServer *grpc.Server
        listener   net.Listener
        storage    *storage.PostgresStorage
}

// NewServerApp creates and returns a new instance of the ServerApp initialized with the provided
// configuration. It sets up logging, initializes storage connections (PostgreSQL and MinIO),
// configures gRPC server with interceptors for logging, hashing, and token validation,
// and prepares a TLS listener.
//
// Parameters:
//   - cfg: A pointer to the ServerConfig struct containing all necessary server configurations.
//
// Returns:
//   - A pointer to the newly created ServerApp instance.
//   - An error if any initialization step fails.
func NewServerApp(cfg *config.ServerConfig) (*ServerApp, error) <span class="cov0" title="0">{
        if err := logger.Initialize(cfg.LogLevel); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">repo, err := storage.NewPostgresStorage(cfg.DatabaseDSN)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error init postgres storage", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">minioClient, err := storage.NewMinioStorage(cfg.MinioEndpoint, cfg.MinioAccessKeyID, cfg.MinioSecretAccessKey, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error init minio storage", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">gRPCServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(
                        interceptors.LoggingInterceptor,
                        interceptors.HashInterceptor(cfg.Key),
                        interceptors.ValidateToken(cfg.JWTKey),
                ),
        )
        proto.RegisterGophkeeperServer(gRPCServer, &amp;handlers.GophkeeperServer{
                RetryCount:  cfg.RetryCount,
                Storage:     repo,
                Minio:       minioClient,
                DatabaseKey: cfg.DatabaseKey,
                JWTKey:      cfg.JWTKey,
        })
        listener, err := getTLSListener(cfg.ServerAddress.Address, cfg.CryptoKeyPublic, cfg.CryptoKeyPrivate)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("failed to create TLS listener", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ServerApp{
                config:     cfg,
                gRPCServer: gRPCServer,
                listener:   listener,
                storage:    repo,
        }, nil</span>
}

// getTLSListener creates a TLS listener on the specified address using provided public and private keys.
//
// Parameters:
//   - addr: The network address to listen on.
//   - certFile: Path to the certificate file.
//   - keyFile: Path to the private key file.
//
// Returns:
//   - A net.Listener instance configured for TLS.
//   - An error if the listener creation fails.
func getTLSListener(addr, certFile, keyFile string) (net.Listener, error) <span class="cov0" title="0">{
        cert, err := tls.LoadX509KeyPair(certFile, keyFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cfg := &amp;tls.Config{
                Certificates: []tls.Certificate{cert},
                NextProtos:   []string{"h2"}}
        return tls.Listen("tcp", addr, cfg)</span>
}

// Run starts the gRPC server on the configured listener and handles graceful shutdown.
// It listens for OS signals to trigger a graceful stop of the server.
func (s *ServerApp) Run() <span class="cov0" title="0">{
        logger.Log.Info("running server", zap.String("address", s.config.ServerAddress.Address))
        go func() </span><span class="cov0" title="0">{
                if err := s.gRPCServer.Serve(s.listener); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Fatal("failed to serve", zap.Error(err))
                }</span>
        }()
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)
        &lt;-quit
        s.Stop()</span>
}

// Stop gracefully shuts down the gRPC server and closes the storage connection.
func (s *ServerApp) Stop() <span class="cov0" title="0">{
        logger.Log.Info("stopping server", zap.String("address", s.config.ServerAddress.Address))
        if s.gRPCServer != nil </span><span class="cov0" title="0">{
                s.gRPCServer.GracefulStop()
        }</span>
        <span class="cov0" title="0">if err := s.storage.Close(); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error closing storage before exit", zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright © 2024 MIKHAIL SIRKIN &lt;skim991@gmail.com&gt;
*/

// Package main serves as the entry point for the GophKeeper application.
// It initializes and runs the command-line interface (CLI) using the cmd package,
// which handles all user commands and interactions. The package also provides
// build information such as version and date, which are printed at startup.
package main

import (
        "fmt"

        "github.com/Vidkin/gophkeeper/app/cmd"
)

// buildVersion holds the build version of the application.
// It is set during the build process and defaults to "N/A" if not specified.
var buildVersion = "N/A"

// buildDate holds the build date of the application.
// It is set during the build process and defaults to "N/A" if not specified.
var buildDate = "N/A"

// main serves as the entry point for the GophKeeper application. It performs the following tasks:
//
//  1. Prints the build version and build date of the application.
//  2. Executes the command-line interface (CLI) using the cmd.Execute() function,
//     which handles all user commands and interactions.
func main() <span class="cov0" title="0">{
        fmt.Printf("Build version: %s\nBuild date: %s\n---------------\n", buildVersion, buildDate)
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright © 2024 MIKHAIL SIRKIN &lt;skim991@gmail.com&gt;
*/

// Package main serves as the entry point for the GophKeeper application.
// It initializes and runs the server using configurations provided by the config package,
// and handles server operations through the app package.
package main

import (
        "fmt"

        "github.com/Vidkin/gophkeeper/app"
        "github.com/Vidkin/gophkeeper/internal/config"
)

// buildVersion holds the build version of the application.
// It is set during the build process and defaults to "N/A" if not specified.
var buildVersion = "N/A"

// buildDate holds the build date of the application.
// It is set during the build process and defaults to "N/A" if not specified.
var buildDate = "N/A"

// main serves as the entry point for the GophKeeper server. It performs the following tasks:
//
// 1. Prints the build version and build date of the application.
// 2. Loads the server configuration using config.NewServerConfig().
// 3. Initializes the server application using app.NewServerApp(cfg).
// 4. Starts the server by calling serverApp.Run().
func main() <span class="cov0" title="0">{
        fmt.Printf("Build version: %s\nBuild date: %s\n---------------\n", buildVersion, buildDate)
        cfg, err := config.NewServerConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">serverApp, err := app.NewServerApp(cfg)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">serverApp.Run()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package client

import (
        "context"
        "encoding/base64"
        "fmt"
        "os"
        "path"
        "time"

        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        pb "google.golang.org/protobuf/proto"

        "github.com/Vidkin/gophkeeper/pkg/hash"
        "github.com/Vidkin/gophkeeper/proto"
)

// Auth authenticates a user with the GophKeeper server using the provided login and password.
//
// Parameters:
//   - login: The user's login name.
//   - password: The user's password.
//
// Returns:
//   - An error if any step in the process fails, including gRPC connection issues,
//     marshaling errors, or file operations related to the JWT token.
func Auth(login, password string) error <span class="cov0" title="0">{
        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">cred := proto.Credentials{
                Login:    login,
                Password: password,
        }
        req := &amp;proto.AuthorizeRequest{
                Credentials: &amp;cred,
        }

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md := metadata.New(map[string]string{"HashSHA256": hEnc})
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">resp, err := client.Authorize(ctxTimeout, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = os.Remove(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">f, err := os.Create(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close jwt temp file")
                }</span>
        }(f)

        <span class="cov0" title="0">if _, err = f.WriteString(resp.Token); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Successfully authorized!")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package client

import (
        "context"
        "encoding/base64"
        "errors"
        "fmt"
        "os"
        "path"
        "strconv"
        "time"

        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        pb "google.golang.org/protobuf/proto"

        "github.com/Vidkin/gophkeeper/pkg/aes"
        "github.com/Vidkin/gophkeeper/pkg/hash"
        "github.com/Vidkin/gophkeeper/proto"
)

// AddCard adds a new bank card to the GophKeeper server after encrypting its sensitive information.
//
// Parameters:
//   - card: A pointer to the proto.BankCard struct containing the card details to be added.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, encryption, or gRPC communication.
func AddCard(card *proto.BankCard) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        card.Cvv, err = aes.Encrypt(viper.GetString("secret_key"), card.Cvv)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">card.Owner, err = aes.Encrypt(viper.GetString("secret_key"), card.Owner)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">card.Number, err = aes.Encrypt(viper.GetString("secret_key"), card.Number)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">card.Description, err = aes.Encrypt(viper.GetString("secret_key"), card.Description)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">card.ExpireDate, err = aes.Encrypt(viper.GetString("secret_key"), card.ExpireDate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.AddBankCardRequest{
                Card: card,
        }

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">_, err = client.AddBankCard(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Successfully add a new bank card!")
        return err</span>
}

// GetAllCards retrieves all bank cards from the GophKeeper server and decrypts their information for display.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, gRPC communication, or decryption.
func GetAllCards() error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.GetBankCardsRequest{}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">resp, err := client.GetBankCards(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Bank cards:")
        for _, card := range resp.Cards </span><span class="cov0" title="0">{
                card.Owner, err = aes.Decrypt(viper.GetString("secret_key"), card.Owner)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">card.Description, err = aes.Decrypt(viper.GetString("secret_key"), card.Description)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">card.Number, err = aes.Decrypt(viper.GetString("secret_key"), card.Number)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">card.Cvv, err = aes.Decrypt(viper.GetString("secret_key"), card.Cvv)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">card.ExpireDate, err = aes.Decrypt(viper.GetString("secret_key"), card.ExpireDate)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("id=%d, number=%s, owner=%s, cvv=%s, expire=%s, description=%s\n", card.Id, card.Number, card.Cvv, card.Owner, card.Description, card.ExpireDate)</span>
        }
        <span class="cov0" title="0">return err</span>
}

// GetCard retrieves a specific bank card by its ID from the GophKeeper server and decrypts its information for display.
//
// Parameters:
//   - cardID: The ID of the bank card to retrieve.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, gRPC communication, or decryption.
func GetCard(cardID int64) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.GetBankCardRequest{Id: strconv.FormatInt(cardID, 10)}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">resp, err := client.GetBankCard(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Bank card:")
        resp.Card.Owner, err = aes.Decrypt(viper.GetString("secret_key"), resp.Card.Owner)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
        }</span>
        <span class="cov0" title="0">resp.Card.Description, err = aes.Decrypt(viper.GetString("secret_key"), resp.Card.Description)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
        }</span>
        <span class="cov0" title="0">resp.Card.Number, err = aes.Decrypt(viper.GetString("secret_key"), resp.Card.Number)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
        }</span>
        <span class="cov0" title="0">resp.Card.Cvv, err = aes.Decrypt(viper.GetString("secret_key"), resp.Card.Cvv)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
        }</span>
        <span class="cov0" title="0">resp.Card.ExpireDate, err = aes.Decrypt(viper.GetString("secret_key"), resp.Card.ExpireDate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt card info, check secret key, original error: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf(
                "id=%d, number=%s, owner=%s, cvv=%s, expire=%s, description=%s\n",
                resp.Card.Id, resp.Card.Number, resp.Card.Cvv, resp.Card.Owner, resp.Card.Description, resp.Card.ExpireDate)
        return err</span>
}

// RemoveCard removes a bank card from the GophKeeper server by its ID.
//
// Parameters:
//   - cardID: The ID of the bank card to remove.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, gRPC communication, or authorization issues.
func RemoveCard(cardID int64) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.RemoveBankCardRequest{Id: strconv.FormatInt(cardID, 10)}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">_, err = client.RemoveBankCard(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Bank card has been successfully removed")
        return err</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package client

import (
        "crypto/tls"
        "crypto/x509"
        "errors"
        "os"

        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        "github.com/Vidkin/gophkeeper/proto"
)

// TokenFileName is the name of the temporary file used to store the JWT token.
const TokenFileName = "gophkeeperJWT.tmp"

// NewGophkeeperClient creates a new gRPC client for the GophKeeper server with secure TLS credentials.
//
// It reads the server address and the public key certificate path from the configuration,
// establishes a TLS connection using the provided CA certificate, and returns a new GophkeeperClient instance
// along with the gRPC connection.
//
// Returns:
//   - A pointer to the GophkeeperClient interface for making gRPC calls.
//   - A pointer to the grpc.ClientConn for managing the connection.
//   - An error if any step in the process fails, including reading the certificate,
//     appending it to the certificate pool, or establishing the gRPC connection.
func NewGophkeeperClient() (proto.GophkeeperClient, *grpc.ClientConn, error) <span class="cov0" title="0">{
        serverAddress := viper.GetString("address")
        certPath := viper.GetString("crypto_key_public_path")

        certPool := x509.NewCertPool()
        caCert, err := os.ReadFile(certPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if ok := certPool.AppendCertsFromPEM(caCert); !ok </span><span class="cov0" title="0">{
                return nil, nil, errors.New("error add CA cert into the pool")
        }</span>

        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                RootCAs:    certPool,
                NextProtos: []string{"h2"},
        }
        creds := credentials.NewTLS(tlsConfig)
        conn, err := grpc.NewClient(serverAddress, grpc.WithTransportCredentials(creds))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return proto.NewGophkeeperClient(conn), conn, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package client

import (
        "context"
        "encoding/base64"
        "errors"
        "fmt"
        "os"
        "path"
        "strconv"
        "time"

        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        pb "google.golang.org/protobuf/proto"

        "github.com/Vidkin/gophkeeper/pkg/aes"
        "github.com/Vidkin/gophkeeper/pkg/hash"
        "github.com/Vidkin/gophkeeper/proto"
)

// AddCredentials adds new user credentials to the GophKeeper server after encrypting sensitive information.
//
// Parameters:
//   - credentials: A pointer to the proto.Credentials struct containing the login, password, and description.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, encryption, or gRPC communication.
func AddCredentials(credentials *proto.Credentials) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        credentials.Login, err = aes.Encrypt(viper.GetString("secret_key"), credentials.Login)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">credentials.Password, err = aes.Encrypt(viper.GetString("secret_key"), credentials.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">credentials.Description, err = aes.Encrypt(viper.GetString("secret_key"), credentials.Description)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.AddUserCredentialsRequest{
                Credentials: credentials,
        }

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">_, err = client.AddUserCredentials(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Successfully add a new user credentials!")
        return err</span>
}

// GetAllCredentials retrieves all user credentials from the GophKeeper server and decrypts their information for display.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, gRPC communication, or decryption.
func GetAllCredentials() error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.GetUserCredentialsRequest{}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">resp, err := client.GetUserCredentials(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("User credentials:")
        for _, cred := range resp.Credentials </span><span class="cov0" title="0">{
                cred.Login, err = aes.Decrypt(viper.GetString("secret_key"), cred.Login)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt credentials info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">cred.Password, err = aes.Decrypt(viper.GetString("secret_key"), cred.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt credentials info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">cred.Description, err = aes.Decrypt(viper.GetString("secret_key"), cred.Description)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt credentials info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("id=%d, login=%s, password=%s, description=%s\n", cred.Id, cred.Login, cred.Password, cred.Description)</span>
        }
        <span class="cov0" title="0">return err</span>
}

// GetCredentials retrieves a specific user credential by its ID from the GophKeeper server and decrypts its information for display.
//
// Parameters:
//   - credID: The ID of the user credential to retrieve.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, gRPC communication, or decryption.
func GetCredentials(credID int64) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.GetUserCredentialRequest{Id: strconv.FormatInt(credID, 10)}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">resp, err := client.GetUserCredential(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Credentials:")
        resp.Credentials.Login, err = aes.Decrypt(viper.GetString("secret_key"), resp.Credentials.Login)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt credentials info, check secret key, original error: %v", err)
        }</span>

        <span class="cov0" title="0">resp.Credentials.Password, err = aes.Decrypt(viper.GetString("secret_key"), resp.Credentials.Password)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt credentials info, check secret key, original error: %v", err)
        }</span>

        <span class="cov0" title="0">resp.Credentials.Description, err = aes.Decrypt(viper.GetString("secret_key"), resp.Credentials.Description)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt credentials info, check secret key, original error: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf(
                "id=%d, login=%s, password=%s, description=%s\n",
                resp.Credentials.Id, resp.Credentials.Login, resp.Credentials.Password, resp.Credentials.Description)
        return err</span>
}

// RemoveCredentials removes user credentials from the GophKeeper server by its ID.
//
// Parameters:
//   - credID: The ID of the user credential to remove.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, gRPC communication, or authorization issues.
func RemoveCredentials(credID int64) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.RemoveUserCredentialsRequest{Id: strconv.FormatInt(credID, 10)}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">_, err = client.RemoveUserCredentials(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Credentials has been successfully removed")
        return err</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package client

import (
        "bufio"
        "context"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "os"
        "path"
        "time"

        "github.com/spf13/viper"
        "golang.org/x/text/unicode/norm"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        pb "google.golang.org/protobuf/proto"

        "github.com/Vidkin/gophkeeper/pkg/hash"
        "github.com/Vidkin/gophkeeper/proto"
)

// UploadFile uploads a file to the GophKeeper server with an optional description.
//
// Parameters:
//   - filePath: The path to the file to be uploaded.
//   - description: A description of the file being uploaded.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, file opening,
//     gRPC communication, or streaming errors.
func UploadFile(filePath, description string) error <span class="cov0" title="0">{
        tokenFile, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(tokenFile)

        f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close file")
                }</span>
        }(f)
        <span class="cov0" title="0">fStat, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file := proto.File{}
        file.FileSize = fStat.Size()
        file.Description = description
        file.FileName = norm.NFC.String(path.Base(filePath))

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">ctx := context.Background()
        md := metadata.New(map[string]string{"token": token})
        ctx = metadata.NewOutgoingContext(ctx, md)

        reader := bufio.NewReader(f)
        buffer := make([]byte, 1024*1024)

        stream, err := client.Upload(ctx)
        for </span><span class="cov0" title="0">{
                n, err := reader.Read(buffer)
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">req := &amp;proto.FileUploadRequest{
                        FileName:    file.FileName,
                        Description: file.Description,
                        FileSize:    file.FileSize,
                        Chunk:       buffer[:n],
                }
                err = stream.Send(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">_, err = stream.CloseAndRecv()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Successfully upload file!")
        return err</span>
}

// DownloadFile downloads a file from the GophKeeper server and saves it to the specified path.
//
// Parameters:
//   - fileName: The name of the file to download from the server.
//   - filePath: The local path where the file will be saved.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, file creation,
//     gRPC communication, or streaming errors.
func DownloadFile(fileName, filePath string) error <span class="cov0" title="0">{
        tokenFile, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(tokenFile)

        f, err := os.OpenFile(path.Join(filePath, fileName), os.O_WRONLY|os.O_CREATE, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(f *os.File) </span><span class="cov0" title="0">{
                err = f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close file")
                }</span>
        }(f)

        <span class="cov0" title="0">client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">ctx := context.Background()
        md := metadata.New(map[string]string{"token": token})
        ctx = metadata.NewOutgoingContext(ctx, md)

        writer := bufio.NewWriter(f)
        req := &amp;proto.FileDownloadRequest{
                FileName: norm.NFC.String(fileName),
        }
        stream, err := client.Download(ctx, req)
        for </span><span class="cov0" title="0">{
                res, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("error receive file")
                        return err
                }</span>

                <span class="cov0" title="0">_, err = writer.Write(res.Chunk)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to write chunk")
                        return err
                }</span>
        }
        <span class="cov0" title="0">err = writer.Flush()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("failed to flush file")
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Successfully download file!")
        return err</span>
}

// RemoveFile removes a file from the GophKeeper server by its name.
//
// Parameters:
//   - fileName: The name of the file to be removed from the server.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, gRPC communication,
//     or authorization issues.
func RemoveFile(fileName string) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.FileRemoveRequest{FileName: fileName}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">_, err = client.RemoveFile(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("File has been successfully removed")
        return err</span>
}

// GetAllFiles retrieves a list of all files stored on the GophKeeper server and displays their details.
//
// Returns:
//   - An error if any step in the process fails, including JWT file access, gRPC communication,
//     or errors in retrieving the file list.
func GetAllFiles() error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.GetFilesRequest{}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">resp, err := client.GetFiles(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Files:")
        for _, file := range resp.Files </span><span class="cov0" title="0">{
                fmt.Printf("id=%d, fileName=%s, size=%d, description=%s\n", file.Id, norm.NFC.String(file.FileName), file.FileSize, file.Description)
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package client

import (
        "context"
        "encoding/base64"
        "errors"
        "fmt"
        "os"
        "path"
        "strconv"
        "time"

        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        pb "google.golang.org/protobuf/proto"

        "github.com/Vidkin/gophkeeper/pkg/aes"
        "github.com/Vidkin/gophkeeper/pkg/hash"
        "github.com/Vidkin/gophkeeper/proto"
)

// AddNote adds a new note to the GophKeeper server.
//
// Parameters:
//   - note: A pointer to the proto.Note structure containing the text and description of the note.
//
// Returns an error if the operation fails, for example, if re-authorization is required.
func AddNote(note *proto.Note) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        note.Text, err = aes.Encrypt(viper.GetString("secret_key"), note.Text)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">note.Description, err = aes.Encrypt(viper.GetString("secret_key"), note.Description)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.AddNoteRequest{
                Note: note,
        }

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">_, err = client.AddNote(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Successfully add a new user note!")
        return err</span>
}

// GetAllNotes retrieves all user notes from the GophKeeper server.
//
// Returns an error if the operation fails, for example, if re-authorization is required.
func GetAllNotes() error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.GetNotesRequest{}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">resp, err := client.GetNotes(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("User notes:")
        for _, note := range resp.Notes </span><span class="cov0" title="0">{
                note.Text, err = aes.Decrypt(viper.GetString("secret_key"), note.Text)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt note info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">note.Description, err = aes.Decrypt(viper.GetString("secret_key"), note.Description)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrypt note info, check secret key, original error: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Printf("id=%d, text=%s, description=%s\n", note.Id, note.Text, note.Description)</span>
        }
        <span class="cov0" title="0">return err</span>
}

// GetNote retrieves a note by its ID from the GophKeeper server.
//
// Parameters:
//   - noteID: The ID of the note to retrieve.
//
// Returns an error if the operation fails, for example, if re-authorization is required.
func GetNote(noteID int64) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.GetNoteRequest{Id: strconv.FormatInt(noteID, 10)}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">resp, err := client.GetNote(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Note:")
        resp.Note.Text, err = aes.Decrypt(viper.GetString("secret_key"), resp.Note.Text)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt note, check secret key, original error: %v", err)
        }</span>

        <span class="cov0" title="0">resp.Note.Description, err = aes.Decrypt(viper.GetString("secret_key"), resp.Note.Description)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decrypt note, check secret key, original error: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf(
                "id=%d, text=%s, description=%s\n",
                resp.Note.Id, resp.Note.Text, resp.Note.Description)
        return err</span>
}

// RemoveNote removes a note by its ID from the GophKeeper server.
//
// Parameters:
//   - noteID: The ID of the note to remove.
//
// Returns an error if the operation fails, for example, if re-authorization is required.
func RemoveNote(noteID int64) error <span class="cov0" title="0">{
        f, err := os.ReadFile(path.Join(os.TempDir(), TokenFileName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error open JWT file, need to authorize: %v", err)
        }</span>
        <span class="cov0" title="0">token := string(f)

        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">req := &amp;proto.RemoveNoteRequest{Id: strconv.FormatInt(noteID, 10)}

        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        md := metadata.New(map[string]string{"token": token})
        ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md.Append("HashSHA256", hEnc)
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">_, err = client.RemoveNote(ctxTimeout, req)

        if err != nil </span><span class="cov0" title="0">{
                if e, ok := status.FromError(err); ok </span><span class="cov0" title="0">{
                        if e.Code() == codes.PermissionDenied </span><span class="cov0" title="0">{
                                return errors.New("need to re-authorize, call auth command")
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">fmt.Println("Note has been successfully removed")
        return err</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package client

import (
        "context"
        "encoding/base64"
        "fmt"
        "time"

        "github.com/spf13/viper"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        pb "google.golang.org/protobuf/proto"

        "github.com/Vidkin/gophkeeper/pkg/hash"
        "github.com/Vidkin/gophkeeper/proto"
)

// Register registers a new user with the GophKeeper server.
//
// Parameters:
//   - login: The login name of the user.
//   - password: The password for the user account.
//
// Returns an error if the registration fails, for example, if the user already exists
// or if there is a connection issue with the server. If successful, a confirmation message
// is printed to the console.
func Register(login, password string) error <span class="cov0" title="0">{
        client, conn, err := NewGophkeeperClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func(conn *grpc.ClientConn) </span><span class="cov0" title="0">{
                err = conn.Close()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("failed to close grpc connection")
                }</span>
        }(conn)

        <span class="cov0" title="0">cred := proto.Credentials{
                Login:    login,
                Password: password,
        }
        req := &amp;proto.RegisterUserRequest{
                Credentials: &amp;cred,
        }
        ctxTimeout, cancel := context.WithTimeout(context.Background(), 200*time.Millisecond)
        defer cancel()

        if viper.GetString("hash_key") != "" </span><span class="cov0" title="0">{
                data, err := pb.Marshal(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">h := hash.GetHashSHA256(viper.GetString("hash_key"), data)
                hEnc := base64.StdEncoding.EncodeToString(h)
                md := metadata.New(map[string]string{"HashSHA256": hEnc})
                ctxTimeout = metadata.NewOutgoingContext(ctxTimeout, md)</span>
        }

        <span class="cov0" title="0">_, err = client.RegisterUser(ctxTimeout, req)
        if err == nil </span><span class="cov0" title="0">{
                fmt.Println("User successfully registered!")
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
)

// Interval represents a time interval in seconds.
type Interval int

// UnmarshalJSON customizes the JSON unmarshalling for the Interval type.
// It expects a string representation of the interval, which should end with
// the suffix "s" (for seconds). The method converts the string to an integer
// and assigns it to the Interval type.
//
// Returns an error if the input format is invalid or if the conversion fails.
func (i *Interval) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var intervalStr string

        if err := json.Unmarshal(data, &amp;intervalStr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if strings.HasSuffix(intervalStr, "s") </span><span class="cov8" title="1">{
                seconds, err := strconv.Atoi(strings.TrimSuffix(intervalStr, "s"))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*i = Interval(seconds)</span>
        } else<span class="cov8" title="1"> {
                return fmt.Errorf("invalid interval format: %s", intervalStr)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// MarshalJSON customizes the JSON marshalling for the Interval type.
// It converts the Interval value to a string representation ending with "s".
func (i Interval) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // Convert the Interval value to a string and append "s"
        intervalStr := fmt.Sprintf("%ds", i)
        return json.Marshal(intervalStr)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package config

import (
        "encoding/json"
        "errors"
        "flag"
        "os"

        "github.com/caarlos0/env/v6"
        "go.uber.org/zap"

        "github.com/Vidkin/gophkeeper/internal/logger"
)

// ServerConfig holds the configuration settings for the server.
//
// This struct contains various fields that define how the server operates,
// including its address, storage settings, logging preferences, and more.
// The fields can be populated from environment variables, allowing for
// flexible configuration without hardcoding values.
type ServerConfig struct {
        ServerAddress        *ServerAddress `json:"address"`
        LogLevel             string
        MinioEndpoint        string `env:"MINIO_ENDPOINT"`
        MinioAccessKeyID     string `env:"MINIO_ACCESS_KEY_ID"`
        MinioSecretAccessKey string `env:"MINIO_SECRET_ACCESS_KEY"`
        ConfigPath           string `env:"CONFIG"`
        DatabaseDSN          string `env:"DATABASE_DSN" json:"database_dsn"`
        DatabaseKey          string `env:"DATABASE_KEY"`
        JWTKey               string `env:"JWT_KEY"`
        Key                  string `env:"KEY" json:"hash_key"`
        CryptoKeyPublic      string `env:"CRYPTO_KEY_PUBLIC"`
        CryptoKeyPrivate     string `env:"CRYPTO_KEY_PRIVATE"`
        RetryCount           int
}

// NewServerConfig initializes a new ServerConfig instance with default values
// and parses command-line flags and environment variables to populate its fields
//
// Returns:
// - A pointer to the newly created and initialized ServerConfig instance.
// - An error if the configuration parsing fails; otherwise, nil.
func NewServerConfig() (*ServerConfig, error) <span class="cov0" title="0">{
        var config ServerConfig
        config.ServerAddress = NewServerAddress()
        config.RetryCount = 3
        err := config.parseFlags()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;config, nil</span>
}

func (config *ServerConfig) parseFlags() error <span class="cov0" title="0">{
        fs := flag.NewFlagSet("serverFlagSet", flag.ContinueOnError)

        fs.Var(config.ServerAddress, "a", "Net address host:port")
        fs.StringVar(&amp;config.ConfigPath, "c", "", "Path to json config file")
        fs.StringVar(&amp;config.ConfigPath, "config", "", "Path to json config file")
        fs.StringVar(&amp;config.LogLevel, "l", "info", "Log level")
        fs.StringVar(&amp;config.DatabaseDSN, "d", "", "Database DSN")
        fs.StringVar(&amp;config.Key, "k", "", "Hash key")
        fs.StringVar(&amp;config.JWTKey, "j", "", "JWT secret key")
        fs.StringVar(&amp;config.MinioEndpoint, "minio-endpoint", "", "Minio endpoint host:port")
        fs.StringVar(&amp;config.MinioSecretAccessKey, "minio-secret", "", "Minio secret access key")
        fs.StringVar(&amp;config.MinioAccessKeyID, "minio-id", "", "Minio access key ID")
        fs.StringVar(&amp;config.DatabaseKey, "db-key", "", "Database secret key to encrypt/decrypt data (32 bytes length)")
        fs.StringVar(&amp;config.CryptoKeyPublic, "crypto-key-public", "", "Path to public key pem file")
        fs.StringVar(&amp;config.CryptoKeyPrivate, "crypto-key-private", "", "Path to private key pem file")

        if err := fs.Parse(os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error parse server flags", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">if config.ConfigPath != "" </span><span class="cov0" title="0">{
                if err := config.loadJSONConfig(config.ConfigPath); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error parse json config file", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">err := env.Parse(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.ServerAddress.Address == "" </span><span class="cov0" title="0">{
                config.ServerAddress.Address = config.ServerAddress.String()
        }</span>

        <span class="cov0" title="0">if config.CryptoKeyPublic == "" || config.CryptoKeyPrivate == "" </span><span class="cov0" title="0">{
                return errors.New("you must pass the path to public and private keys pem files, see --help")
        }</span>

        <span class="cov0" title="0">if config.DatabaseKey == "" || len(config.DatabaseKey) != 32 </span><span class="cov0" title="0">{
                return errors.New("you must pass the database secret key (32-bytes), see --help")
        }</span>

        <span class="cov0" title="0">if config.MinioEndpoint == "" </span><span class="cov0" title="0">{
                return errors.New("you must pass correct endpoint to minio service, see --help")
        }</span>

        <span class="cov0" title="0">if config.MinioSecretAccessKey == "" </span><span class="cov0" title="0">{
                return errors.New("you must pass correct minio secret access key, see --help")
        }</span>

        <span class="cov0" title="0">if config.MinioAccessKeyID == "" </span><span class="cov0" title="0">{
                return errors.New("you must pass correct minio access key id, see --help")
        }</span>

        <span class="cov0" title="0">if config.JWTKey == "" </span><span class="cov0" title="0">{
                return errors.New("you must pass the JWT secret key, see --help")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (config *ServerConfig) loadJSONConfig(path string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var jsonServerConfig ServerConfig
        if err = json.Unmarshal(data, &amp;jsonServerConfig); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if config.ServerAddress.Address == "" </span><span class="cov0" title="0">{
                config.ServerAddress = jsonServerConfig.ServerAddress
        }</span>

        <span class="cov0" title="0">dbDSNPassed := false
        hashKeyPassed := false

        args := os.Args[1:]
        for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                arg := args[i]
                switch arg </span>{
                case "--d", "-d":<span class="cov0" title="0">
                        dbDSNPassed = true</span>
                case "--k", "-k":<span class="cov0" title="0">
                        hashKeyPassed = true</span>
                }
        }

        <span class="cov0" title="0">if !dbDSNPassed </span><span class="cov0" title="0">{
                config.DatabaseDSN = jsonServerConfig.DatabaseDSN
        }</span>

        <span class="cov0" title="0">if !hashKeyPassed </span><span class="cov0" title="0">{
                config.Key = jsonServerConfig.Key
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package config

import (
        "encoding/json"
        "errors"
        "net"
        "strconv"
        "strings"
)

const (
        DefaultServerAddress = "127.0.0.1"
        DefaultServerPort    = 8080
)

// ServerAddress represents the host and port information for a server.
//
// This struct is used to manage the server's address configuration, including
// the host name or IP address and the port number. It can be initialized with
// default values and can also be populated from environment variables.
type ServerAddress struct {
        Address string `env:"ADDRESS"`
        Host    string
        Port    int
}

// NewServerAddress creates and returns a new instance of the ServerAddress struct
// initialized with default values.
//
// The default host is set to "localhost" and the default port is set to 8080.
// This function is useful for quickly obtaining a ServerAddress instance
// without needing to specify the host and port manually.
//
// Returns:
// - Pointer to the newly created ServerAddress instance.
func NewServerAddress() *ServerAddress <span class="cov8" title="1">{
        return &amp;ServerAddress{
                Host: DefaultServerAddress,
                Port: DefaultServerPort,
        }
}</span>

// String returns the string representation of the ServerAddress in the format "host:port".
//
// Returns:
//   - The server address string formatted as "host:port".
func (s *ServerAddress) String() string <span class="cov8" title="1">{
        return s.Host + ":" + strconv.Itoa(s.Port)
}</span>

// Set updates the Host and Port fields of the ServerAddress struct based on the provided
// address string in the format "host:port".
//
// Parameters:
//   - flagRunAddr: The address string to set, in the format "host:port".
//
// Returns:
//   - An error if the input format is invalid or if the port cannot be converted to an integer.
func (s *ServerAddress) Set(flagRunAddr string) error <span class="cov8" title="1">{
        splittedAddress := strings.Split(flagRunAddr, ":")

        if len(splittedAddress) != 2 </span><span class="cov8" title="1">{
                return errors.New("need address in a form host:port")
        }</span>

        <span class="cov8" title="1">port, err := strconv.Atoi(splittedAddress[1])

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">s.Host = splittedAddress[0]
        s.Port = port

        return nil</span>
}

// UnmarshalJSON unmarshals a JSON object into a ServerAddress struct.
// It expects the JSON to contain an "address" field in the format "host:port".
//
// Parameters:
//   - data: A byte slice containing the JSON data to unmarshal.
//
// Returns:
//   - An error if the input format is invalid or if the port cannot be converted to an integer.
func (s *ServerAddress) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        address := strings.Trim(string(data), "\"")
        host, portStr, err := net.SplitHostPort(address)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.Host = host
        port, err := strconv.Atoi(portStr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">s.Port = port
        return nil</span>
}

// MarshalJSON marshals the ServerAddress struct into a JSON string
// in the format "host:port".
func (s *ServerAddress) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        address := s.String()
        return json.Marshal(address)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/internal/model"
        "github.com/Vidkin/gophkeeper/pkg/interceptors"
        "github.com/Vidkin/gophkeeper/proto"
)

// AddBankCard adds a new bank card for the user.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.AddBankCardRequest structure containing the bank card details.
//
// Returns:
//   - An empty response (emptypb.Empty) if the operation is successful.
//   - An error if the operation fails, for example, if required fields are missing or if
//     there is an internal error while adding the card to the storage.
//
// The function validates the input fields and logs an error if any required field is missing.
// It then creates a model.BankCard instance and attempts to add it to the storage.
func (g *GophkeeperServer) AddBankCard(ctx context.Context, in *proto.AddBankCardRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if in.Card.Cvv == "" || in.Card.ExpireDate == "" || in.Card.Number == "" || in.Card.Owner == "" </span><span class="cov0" title="0">{
                logger.Log.Error("you must provide: CVV, expire date, card number, card owner")
                return nil, status.Errorf(codes.InvalidArgument, "you must provide: CVV, expire date, card number, card owner")
        }</span>

        <span class="cov0" title="0">card := &amp;model.BankCard{
                UserID:      ctx.Value(interceptors.UserID).(int64),
                CVV:         in.Card.Cvv,
                Owner:       in.Card.Owner,
                Number:      in.Card.Number,
                ExpireDate:  in.Card.ExpireDate,
                Description: in.Card.Description,
        }

        if err := g.Storage.AddCard(ctx, card); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error add bank card", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error add bank card")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/pkg/interceptors"
        "github.com/Vidkin/gophkeeper/proto"
)

// GetBankCards retrieves all bank cards associated with the user.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - _: A pointer to the proto.GetBankCardsRequest structure (not used in this method).
//
// Returns:
//   - A pointer to the proto.GetBankCardsResponse containing the list of bank cards.
//   - An error if the operation fails, for example, if there is an internal error while
//     retrieving the cards from the storage.
//
// The function fetches the user's bank cards from the storage and constructs a response
// containing the card details. If an error occurs during the retrieval, it logs the error
// and returns an appropriate gRPC status code.
func (g *GophkeeperServer) GetBankCards(ctx context.Context, _ *proto.GetBankCardsRequest) (*proto.GetBankCardsResponse, error) <span class="cov0" title="0">{
        var response proto.GetBankCardsResponse

        cards, err := g.Storage.GetBankCards(ctx, ctx.Value(interceptors.UserID).(int64))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get bank cards from DB", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error get bank cards from DB")
        }</span>

        <span class="cov0" title="0">protoCards := make([]*proto.BankCard, len(cards))
        for i, card := range cards </span><span class="cov0" title="0">{
                protoCards[i] = &amp;proto.BankCard{
                        Owner:       card.Owner,
                        Number:      card.Number,
                        ExpireDate:  card.ExpireDate,
                        Cvv:         card.CVV,
                        Description: card.Description,
                        Id:          card.ID,
                }
        }</span>
        <span class="cov0" title="0">response.Cards = protoCards
        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package handlers

import (
        "context"
        "strconv"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/proto"
)

// GetBankCard retrieves a specific bank card by its ID.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.GetBankCardRequest structure containing the ID of the bank card.
//
// Returns:
//   - A pointer to the proto.GetBankCardResponse containing the details of the requested bank card.
//   - An error if the operation fails, for example, if the provided ID is invalid or if there is
//     an internal error while retrieving the card from the storage.
//
// The function converts the card ID from a string to an integer and fetches the corresponding
// bank card from the storage. If an error occurs during the retrieval, it logs the error
// and returns an appropriate gRPC status code.
func (g *GophkeeperServer) GetBankCard(ctx context.Context, in *proto.GetBankCardRequest) (*proto.GetBankCardResponse, error) <span class="cov0" title="0">{
        cardID, err := strconv.Atoi(in.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "missing bank card id")
        }</span>
        <span class="cov0" title="0">var response proto.GetBankCardResponse

        card, err := g.Storage.GetBankCard(ctx, int64(cardID))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get bank card from DB", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error get bank card from DB")
        }</span>

        <span class="cov0" title="0">protoCard := &amp;proto.BankCard{
                Owner:       card.Owner,
                Number:      card.Number,
                ExpireDate:  card.ExpireDate,
                Cvv:         card.CVV,
                Description: card.Description,
                Id:          card.ID,
        }
        response.Card = protoCard
        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package handlers

import (
        "context"
        "strconv"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/proto"
)

// RemoveBankCard removes a bank card associated with the user by its ID.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.RemoveBankCardRequest structure containing the ID of the bank card to remove.
//
// Returns:
//   - An empty response (emptypb.Empty) if the operation is successful.
//   - An error if the operation fails, for example, if the provided ID is missing or invalid,
//     or if there is an internal error while removing the card from the storage.
//
// The function validates the input ID, converts it to an integer, and attempts to remove the
// corresponding bank card from the storage. If an error occurs during the removal, it logs the
// error and returns an appropriate gRPC status code.
func (g *GophkeeperServer) RemoveBankCard(ctx context.Context, in *proto.RemoveBankCardRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if in.Id == "" </span><span class="cov0" title="0">{
                logger.Log.Error("you must provide card id")
                return nil, status.Errorf(codes.InvalidArgument, "you must provide card id")
        }</span>

        <span class="cov0" title="0">cardID, err := strconv.ParseInt(in.Id, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("invalid card id")
                return nil, status.Errorf(codes.InvalidArgument, "invalid card id")
        }</span>

        <span class="cov0" title="0">if err = g.Storage.RemoveBankCard(ctx, cardID); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error remove bank card", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error remove bank card")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package handlers

import (
        "context"

        "github.com/Vidkin/gophkeeper/proto"
)

// Echo returns the received message back to the caller.
//
// Parameters:
//   - ctx: The context for the gRPC call (not used in this method).
//   - in: A pointer to the proto.EchoRequest structure containing the message to echo.
//
// Returns:
//   - A pointer to the proto.EchoResponse containing the echoed message.
//   - An error if the operation fails (this method does not generate errors).
//
// The function simply takes the input message from the request and returns it in the response.
func (g *GophkeeperServer) Echo(_ context.Context, in *proto.EchoRequest) (*proto.EchoResponse, error) <span class="cov0" title="0">{
        var response proto.EchoResponse
        response.Message = in.Message
        return &amp;response, nil
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package handlers

import (
        "fmt"
        "io"

        "github.com/golang-jwt/jwt/v4"
        "github.com/minio/minio-go/v7"
        "go.uber.org/zap"
        "golang.org/x/text/unicode/norm"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        jwtPKG "github.com/Vidkin/gophkeeper/pkg/jwt"
        "github.com/Vidkin/gophkeeper/proto"
)

// Download streams a file to the client.
//
// Parameters:
//   - in: A pointer to the proto.FileDownloadRequest structure containing the name of the file to download.
//   - srv: A proto.Gophkeeper_DownloadServer interface for sending the file chunks back to the client.
//
// Returns:
//   - An error if the operation fails, for example, if the token is missing, invalid, or if there are
//     issues retrieving the file from storage or MinIO.
//
// The function first retrieves the JWT token from the incoming context metadata. It then parses the
// token and validates it. If the token is valid, it retrieves the file information from the storage
// and streams the file in chunks to the client. If any errors occur during these processes, they are
// logged, and appropriate gRPC status codes are returned.
func (g *GophkeeperServer) Download(in *proto.FileDownloadRequest, srv proto.Gophkeeper_DownloadServer) error <span class="cov0" title="0">{
        var tokenString string
        if md, ok := metadata.FromIncomingContext(srv.Context()); ok </span><span class="cov0" title="0">{
                values := md.Get("token")
                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        tokenString = values[0]
                }</span>
        }
        <span class="cov0" title="0">if len(tokenString) == 0 </span><span class="cov0" title="0">{
                return status.Error(codes.PermissionDenied, "missing token")
        }</span>

        <span class="cov0" title="0">claims := &amp;jwtPKG.Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims,
                func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                logger.Log.Error("unexpected signing method")
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return []byte(g.JWTKey), nil</span>
                })

        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                logger.Log.Error("error parse claims", zap.Error(err))
                return status.Errorf(codes.PermissionDenied, "error parse claims")
        }</span>

        <span class="cov0" title="0">fileName := norm.NFC.String(in.FileName)
        if fileName == "" </span><span class="cov0" title="0">{
                logger.Log.Error("file name is required")
                return status.Error(codes.InvalidArgument, "file name is required")
        }</span>

        <span class="cov0" title="0">fileInfo, err := g.Storage.GetFile(srv.Context(), fileName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error getting file info", zap.Error(err))
                return status.Error(codes.Internal, "error getting file info")
        }</span>

        <span class="cov0" title="0">object, err := g.Minio.GetObject(srv.Context(), fileInfo.BucketName, fileInfo.FileName, minio.GetObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error getting object from MinIO", zap.Error(err))
                return status.Error(codes.Internal, "error getting object from MinIO")
        }</span>

        <span class="cov0" title="0">var totalSize int64
        chunk := make([]byte, 1024)
        for </span><span class="cov0" title="0">{
                clear(chunk)
                n, err := object.Read(chunk)
                if err == io.EOF </span><span class="cov0" title="0">{
                        if n != 0 </span><span class="cov0" title="0">{
                                totalSize += int64(n)

                                resp := proto.FileDownloadResponse{
                                        Chunk:       chunk[:n],
                                        FileSize:    int64(n),
                                        Filename:    fileInfo.FileName,
                                        Description: fileInfo.Description,
                                }

                                if err = srv.Send(&amp;resp); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error send chunk", zap.Error(err))
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error reading object", zap.Error(err))
                        return status.Error(codes.Internal, "error reading object")
                }</span>
                <span class="cov0" title="0">totalSize += int64(n)

                resp := proto.FileDownloadResponse{
                        Chunk:       chunk[:n],
                        FileSize:    int64(n),
                        Filename:    fileInfo.FileName,
                        Description: fileInfo.Description,
                }

                if err = srv.Send(&amp;resp); err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error send chunk", zap.Error(err))
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/pkg/interceptors"
        "github.com/Vidkin/gophkeeper/proto"
)

// GetFiles retrieves all files associated with the user.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - _: A pointer to the proto.GetFilesRequest structure (not used in this method).
//
// Returns:
//   - A pointer to the proto.GetFilesResponse containing the list of files.
//   - An error if the operation fails, for example, if there is an internal error while
//     retrieving the files from the storage.
//
// The function fetches the user's files from the storage and constructs a response
// containing the file details. If an error occurs during the retrieval, it logs the error
// and returns an appropriate gRPC status code.
func (g *GophkeeperServer) GetFiles(ctx context.Context, _ *proto.GetFilesRequest) (*proto.GetFilesResponse, error) <span class="cov0" title="0">{
        var response proto.GetFilesResponse

        files, err := g.Storage.GetFiles(ctx, ctx.Value(interceptors.UserID).(int64))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get files from DB", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error get files from DB")
        }</span>

        <span class="cov0" title="0">protoFiles := make([]*proto.File, len(files))
        for i, file := range files </span><span class="cov0" title="0">{
                protoFiles[i] = &amp;proto.File{}
                protoFiles[i].Id = file.ID
                protoFiles[i].FileName = file.FileName
                protoFiles[i].FileSize = file.FileSize
                protoFiles[i].Description = file.Description
                protoFiles[i].CreatedAt = file.CreatedAt
        }</span>
        <span class="cov0" title="0">response.Files = protoFiles
        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package handlers

import (
        "context"

        "github.com/minio/minio-go/v7"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/internal/storage"
        "github.com/Vidkin/gophkeeper/proto"
)

// RemoveFile removes a file associated with the user from both the storage and MinIO.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.FileRemoveRequest structure, which contains the name of the file to be removed.
//
// Returns:
//   - A pointer to an empty proto.Empty response indicating successful removal of the file.
//   - An error if the operation fails, for example, if the file name is not provided, if the file is not found,
//     or if there is an internal error while removing the file from MinIO or the database.
//
// The function first checks if the file name is provided in the request. If not, it logs an error and returns
// an InvalidArgument status. It then attempts to retrieve the file from the storage. If the file is not found,
// it logs the error and returns a NotFound status. If the file is found, it proceeds to remove the file from
// MinIO. If an error occurs during the removal from MinIO, it logs the error and returns an Internal status.
// Finally, it attempts to remove the file from the database, logging any errors that occur and returning an
// Internal status if the operation fails. If all operations are successful, it returns an empty response.
func (g *GophkeeperServer) RemoveFile(ctx context.Context, in *proto.FileRemoveRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if in.FileName == "" </span><span class="cov0" title="0">{
                logger.Log.Error("you must provide file name")
                return nil, status.Errorf(codes.InvalidArgument, "you must provide file name")
        }</span>

        <span class="cov0" title="0">file, err := g.Storage.GetFile(ctx, in.FileName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("file not found", zap.Error(err))
                return nil, status.Errorf(codes.NotFound, "file not found")
        }</span>

        <span class="cov0" title="0">err = g.Minio.RemoveObject(ctx, storage.MinioBucketName, file.FileName, minio.RemoveObjectOptions{ForceDelete: true})
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error remove file from minio", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error remove file from minio")
        }</span>

        <span class="cov0" title="0">if err = g.Storage.RemoveFile(ctx, in.FileName); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error remove file from DB", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error remove file from DB")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package handlers

import (
        "context"
        "fmt"
        "io"

        "github.com/golang-jwt/jwt/v4"
        "github.com/minio/minio-go/v7"
        "go.uber.org/zap"
        "golang.org/x/text/unicode/norm"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/internal/storage"
        jwtPKG "github.com/Vidkin/gophkeeper/pkg/jwt"
        "github.com/Vidkin/gophkeeper/proto"
)

// Upload handles the streaming upload of a file to MinIO and records its metadata in the database.
//
// This function implements the gRPC server-side streaming method for uploading files. It expects a stream of
// `proto.FileUploadRequest` messages containing file chunks and metadata. The function performs the following
//
// Parameters:
//   - stream: The gRPC server-side stream for uploading the file, which provides methods to receive file
//     upload requests and send responses.
//
// Returns:
//   - An error if any step in the upload process fails, indicating the type of error encountered.
func (g *GophkeeperServer) Upload(stream proto.Gophkeeper_UploadServer) error <span class="cov0" title="0">{
        var fileName, description string
        var fileSize int64
        var tokenString string

        if md, ok := metadata.FromIncomingContext(stream.Context()); ok </span><span class="cov0" title="0">{
                values := md.Get("token")
                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        tokenString = values[0]
                }</span>
        }
        <span class="cov0" title="0">if len(tokenString) == 0 </span><span class="cov0" title="0">{
                return status.Error(codes.PermissionDenied, "missing token")
        }</span>

        <span class="cov0" title="0">claims := &amp;jwtPKG.Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims,
                func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                logger.Log.Error("unexpected signing method")
                                return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return []byte(g.JWTKey), nil</span>
                })

        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                logger.Log.Error("error parse claims", zap.Error(err))
                return status.Errorf(codes.PermissionDenied, "error parse claims")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        pr, pw := io.Pipe()

        req, err := stream.Recv()
        if err == io.EOF </span><span class="cov0" title="0">{
                logger.Log.Error("empty file")
                return status.Errorf(codes.FailedPrecondition, "empty file")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error receive file", zap.Error(err))
                return status.Errorf(codes.Internal, "error receive file")
        }</span>

        <span class="cov0" title="0">fileName = norm.NFC.String(req.FileName)
        description = req.Description
        fileSize = req.FileSize
        if fileName == "" || fileSize == 0 </span><span class="cov0" title="0">{
                return status.Errorf(codes.InvalidArgument, "filename, file-size are required")
        }</span>
        <span class="cov0" title="0">chunk := req.GetChunk()
        go func() </span><span class="cov0" title="0">{
                defer func(pw *io.PipeWriter) </span><span class="cov0" title="0">{
                        err = pw.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("failed to close pipe writer", zap.Error(err))
                        }</span>
                }(pw)
                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        if chunk != nil </span><span class="cov0" title="0">{
                                if _, err = pw.Write(chunk); err != nil </span><span class="cov0" title="0">{
                                        logger.Log.Error("error writing chunk to pipe", zap.Error(err))
                                        return
                                }</span>
                                <span class="cov0" title="0">chunk = nil</span>
                        }

                        <span class="cov0" title="0">req, err = stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("failed to receive data", zap.Error(err))
                                cancel()
                                return
                        }</span>

                        <span class="cov0" title="0">chunk = req.GetChunk()</span>
                }
        }()

        <span class="cov0" title="0">_, err = g.Minio.PutObject(ctx, storage.MinioBucketName, fileName, pr, fileSize, minio.PutObjectOptions{
                ContentType: "application/octet-stream",
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("failed to upload file to MinIO", zap.Error(err))
                return status.Errorf(codes.Internal, "failed to upload file to MinIO")
        }</span>

        <span class="cov0" title="0">err = g.Storage.AddFile(stream.Context(), storage.MinioBucketName, fileName, description, claims.UserID, fileSize)
        if err != nil </span><span class="cov0" title="0">{
                if errRm := g.Minio.RemoveObject(stream.Context(), storage.MinioBucketName, fileName, minio.RemoveObjectOptions{ForceDelete: true}); errRm != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("failed to remove file from MinIO", zap.Error(err))
                }</span>
                <span class="cov0" title="0">logger.Log.Error("failed to save file info to database", zap.Error(err))
                return status.Errorf(codes.Internal, "failed to upload file to MinIO")</span>
        }

        <span class="cov0" title="0">logger.Log.Info("file uploaded", zap.String("fileName", fileName), zap.String("fileSize", fmt.Sprint(fileSize)))
        return stream.SendAndClose(&amp;proto.FileUploadResponse{
                FileName: fileName,
                FileSize: fileSize,
        })</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package handlers

import (
        "context"
        "strconv"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/proto"
)

// RemoveNote deletes a note associated with the user from the storage.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.RemoveNoteRequest structure, which contains the ID of the note to be removed.
//
// Returns:
//   - A pointer to an empty proto.Empty response indicating successful removal of the note.
//   - An error if the operation fails, for example, if the note ID is not provided, if the note ID is
//     invalid, or if there is an internal error while removing the note from the storage.
func (g *GophkeeperServer) RemoveNote(ctx context.Context, in *proto.RemoveNoteRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if in.Id == "" </span><span class="cov0" title="0">{
                logger.Log.Error("you must provide note id")
                return nil, status.Errorf(codes.InvalidArgument, "you must provide note id")
        }</span>

        <span class="cov0" title="0">noteID, err := strconv.ParseInt(in.Id, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("invalid note id")
                return nil, status.Errorf(codes.InvalidArgument, "invalid note id")
        }</span>

        <span class="cov0" title="0">if err = g.Storage.RemoveNote(ctx, noteID); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error remove note", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error remove note")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/internal/model"
        "github.com/Vidkin/gophkeeper/pkg/interceptors"
        "github.com/Vidkin/gophkeeper/proto"
)

// AddNote creates a new note associated with the user and stores it in the database.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.AddNoteRequest structure, which contains the note to be added.
//
// Returns:
//   - A pointer to an empty proto.Empty response indicating successful addition of the note.
//   - An error if the operation fails, for example, if the note text is not provided or if there is an
//     internal error while adding the note to the storage.
func (g *GophkeeperServer) AddNote(ctx context.Context, in *proto.AddNoteRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if in.Note.Text == "" </span><span class="cov0" title="0">{
                logger.Log.Error("you must provide note text")
                return nil, status.Errorf(codes.InvalidArgument, "you must provide note text")
        }</span>

        <span class="cov0" title="0">note := &amp;model.Note{
                UserID:      ctx.Value(interceptors.UserID).(int64),
                Text:        in.Note.Text,
                Description: in.Note.Description,
        }

        if err := g.Storage.AddNote(ctx, note); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error add note", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error add note")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/pkg/interceptors"
        "github.com/Vidkin/gophkeeper/proto"
)

// GetNotes retrieves all notes associated with the user from the storage.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - _: A pointer to the proto.GetNotesRequest structure (not used in this method).
//
// Returns:
//   - A pointer to the proto.GetNotesResponse containing the list of notes associated with the user.
//   - An error if the operation fails, for example, if there is an internal error while retrieving the
//     notes from the database.
//
// The function fetches the user's notes from the storage using the user ID extracted from the context.
// If an error occurs during the retrieval, it logs the error and returns an Internal status. If the
// operation is successful, it constructs a response containing the notes and returns it.
func (g *GophkeeperServer) GetNotes(ctx context.Context, _ *proto.GetNotesRequest) (*proto.GetNotesResponse, error) <span class="cov0" title="0">{
        var response proto.GetNotesResponse

        notes, err := g.Storage.GetNotes(ctx, ctx.Value(interceptors.UserID).(int64))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get notes from DB", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error get notes from DB")
        }</span>

        <span class="cov0" title="0">protoNotes := make([]*proto.Note, len(notes))
        for i, note := range notes </span><span class="cov0" title="0">{
                protoNotes[i] = &amp;proto.Note{
                        Text:        note.Text,
                        Description: note.Description,
                        Id:          note.ID,
                }
        }</span>
        <span class="cov0" title="0">response.Notes = protoNotes
        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "context"
        "strconv"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/proto"
)

// GetNote retrieves a specific note associated with the user from the storage.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.GetNoteRequest structure, which contains the ID of the note to be retrieved.
//
// Returns:
//   - A pointer to the proto.GetNoteResponse containing the requested note.
//   - An error if the operation fails, for example, if the note ID is invalid or if there is an internal
//     error while retrieving the note from the database.
//
// The function first attempts to convert the note ID from a string to an integer. If the conversion fails,
// it returns an InvalidArgument error. It then retrieves the note from the storage using the note ID.
// If an error occurs during the retrieval, it logs the error and returns an Internal status. If the
// operation is successful, it constructs a response containing the note and returns it.
func (g *GophkeeperServer) GetNote(ctx context.Context, in *proto.GetNoteRequest) (*proto.GetNoteResponse, error) <span class="cov0" title="0">{
        noteID, err := strconv.Atoi(in.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "missing note id")
        }</span>
        <span class="cov0" title="0">var response proto.GetNoteResponse

        note, err := g.Storage.GetNote(ctx, int64(noteID))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get note from DB", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error get note from DB")
        }</span>

        <span class="cov0" title="0">protoNote := &amp;proto.Note{
                Text:        note.Text,
                Description: note.Description,
                Id:          note.ID,
        }
        response.Note = protoNote
        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/pkg/aes"
        "github.com/Vidkin/gophkeeper/pkg/jwt"
        "github.com/Vidkin/gophkeeper/proto"
)

// Authorize authenticates a user based on provided credentials and generates a JWT token.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.AuthorizeRequest structure, which contains the user's login credentials.
//
// Returns:
//   - A pointer to the proto.AuthorizeResponse containing the generated JWT token if authentication is successful.
//   - An error if the operation fails, for example, if the login or password is invalid, if there is an
//     error retrieving the user from the database, or if there is an internal error during token generation.
//
// The function first checks if the login and password are provided in the request. If either is missing,
// it logs an error and returns a PermissionDenied status. It then attempts to retrieve the user from the
// storage using the provided login. If the user is not found or an error occurs during retrieval, it logs
// the error and returns a PermissionDenied status. The function then decrypts the stored password and
// compares it with the provided password. If they do not match, it logs an error and returns a
// PermissionDenied status. If authentication is successful, it generates a JWT token for the user and
// returns it in the response.
func (g *GophkeeperServer) Authorize(ctx context.Context, in *proto.AuthorizeRequest) (*proto.AuthorizeResponse, error) <span class="cov0" title="0">{
        var response proto.AuthorizeResponse
        if in.Credentials.Login == "" || in.Credentials.Password == "" </span><span class="cov0" title="0">{
                logger.Log.Error("invalid user login or password")
                return nil, status.Errorf(codes.PermissionDenied, "invalid user login or password")
        }</span>

        <span class="cov0" title="0">u, err := g.Storage.GetUser(ctx, in.Credentials.Login)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get user from db", zap.Error(err))
                return nil, status.Errorf(codes.PermissionDenied, "invalid user login or password")
        }</span>

        <span class="cov0" title="0">decPwd, err := aes.Decrypt(g.DatabaseKey, u.Password)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error encrypt password", zap.Error(err))
                return nil, status.Errorf(codes.PermissionDenied, "invalid user login or password")
        }</span>

        <span class="cov0" title="0">if in.Credentials.Password != decPwd </span><span class="cov0" title="0">{
                logger.Log.Error("invalid user login or password", zap.Error(err))
                return nil, status.Errorf(codes.PermissionDenied, "invalid user login or password")
        }</span>

        <span class="cov0" title="0">token, err := jwt.BuildJWTString(g.JWTKey, u.ID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error build jwt string", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error build jwt string")
        }</span>

        <span class="cov0" title="0">response.Token = token
        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/internal/model"
        "github.com/Vidkin/gophkeeper/pkg/interceptors"
        "github.com/Vidkin/gophkeeper/proto"
)

// AddUserCredentials stores user credentials in the database.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.AddUserCredentialsRequest structure, which contains the user credentials
//     to be added.
//
// Returns:
//   - A pointer to an empty proto.Empty response indicating successful addition of the user credentials.
//   - An error if the operation fails, for example, if the login or password is not provided, or if there
//     is an internal error while adding the credentials to the storage.
//
// The function first checks if both the login and password are provided in the request. If either is missing,
// it logs an error and returns an InvalidArgument status. It then creates a new Credentials model instance,
// populating it with the user ID (extracted from the context), login, password, and description from the
// request. If an error occurs while adding the credentials to the storage, it logs the error and returns
// an Internal status. If the operation is successful, it returns an empty response.
func (g *GophkeeperServer) AddUserCredentials(ctx context.Context, in *proto.AddUserCredentialsRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if in.Credentials.Login == "" || in.Credentials.Password == "" </span><span class="cov0" title="0">{
                logger.Log.Error("you must provide: login and password")
                return nil, status.Errorf(codes.InvalidArgument, "you must provide: login and password")
        }</span>

        <span class="cov0" title="0">cred := &amp;model.Credentials{
                UserID:      ctx.Value(interceptors.UserID).(int64),
                Login:       in.Credentials.Login,
                Password:    in.Credentials.Password,
                Description: in.Credentials.Description,
        }

        if err := g.Storage.AddUserCredentials(ctx, cred); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error add user credentials", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error add user credentials")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/pkg/interceptors"
        "github.com/Vidkin/gophkeeper/proto"
)

// GetUserCredentials retrieves all user credentials associated with the user from the storage.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - _: A pointer to the proto.GetUserCredentialsRequest structure (not used in this method).
//
// Returns:
//   - A pointer to the proto.GetUserCredentialsResponse containing the list of user credentials.
//   - An error if the operation fails, for example, if there is an internal error while retrieving the
//     credentials from the database.
//
// The function fetches the user's credentials from the storage using the user ID extracted from the context.
// If an error occurs during the retrieval, it logs the error and returns an Internal status. If the
// operation is successful, it constructs a response containing the credentials and returns it.
func (g *GophkeeperServer) GetUserCredentials(ctx context.Context, _ *proto.GetUserCredentialsRequest) (*proto.GetUserCredentialsResponse, error) <span class="cov0" title="0">{
        var response proto.GetUserCredentialsResponse

        creds, err := g.Storage.GetUserCredentials(ctx, ctx.Value(interceptors.UserID).(int64))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get user credentials from DB", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error get user credentials from DB")
        }</span>

        <span class="cov0" title="0">protoCreds := make([]*proto.Credentials, len(creds))
        for i, cred := range creds </span><span class="cov0" title="0">{
                protoCreds[i] = &amp;proto.Credentials{
                        Login:       cred.Login,
                        Password:    cred.Password,
                        Description: cred.Description,
                        Id:          cred.ID,
                }
        }</span>
        <span class="cov0" title="0">response.Credentials = protoCreds
        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package handlers

import (
        "context"
        "strconv"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/proto"
)

// GetUserCredential retrieves a specific user credential associated with the user from the storage.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.GetUserCredentialRequest structure, which contains the ID of the credential
//     to be retrieved.
//
// Returns:
//   - A pointer to the proto.GetUserCredentialResponse containing the requested user credential.
//   - An error if the operation fails, for example, if the credential ID is invalid or if there is an
//     internal error while retrieving the credential from the database.
//
// The function first attempts to convert the credential ID from a string to an integer. If the conversion
// fails, it returns an InvalidArgument error. It then retrieves the credential from the storage using the
// credential ID. If an error occurs during the retrieval, it logs the error and returns an Internal status.
// If the operation is successful, it constructs a response containing the credential and returns it.
func (g *GophkeeperServer) GetUserCredential(ctx context.Context, in *proto.GetUserCredentialRequest) (*proto.GetUserCredentialResponse, error) <span class="cov0" title="0">{
        credID, err := strconv.Atoi(in.Id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "missing credentials id")
        }</span>
        <span class="cov0" title="0">var response proto.GetUserCredentialResponse

        cred, err := g.Storage.GetUserCredential(ctx, int64(credID))
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error get credentials from DB", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error get credentials from DB")
        }</span>

        <span class="cov0" title="0">protoCreds := &amp;proto.Credentials{
                Login:       cred.Login,
                Password:    cred.Password,
                Description: cred.Description,
                Id:          cred.ID,
        }
        response.Credentials = protoCreds
        return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package handlers

import (
        "context"
        "strconv"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/proto"
)

// RemoveUserCredentials deletes a specific user credential associated with the user from the storage.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.RemoveUserCredentialsRequest structure, which contains the ID of the
//     credential to be removed.
//
// Returns:
//   - A pointer to an empty proto.Empty response indicating successful removal of the user credential.
//   - An error if the operation fails, for example, if the credential ID is not provided, if the credential
//     ID is invalid, or if there is an internal error while removing the credential from the storage.
//
// The function first checks if the credential ID is provided in the request. If not, it logs an error and
// returns an InvalidArgument status. It then attempts to parse the credential ID from a string to an int64.
// If the parsing fails, it logs the error and returns an InvalidArgument status. If the credential ID is
// valid, it proceeds to remove the credential from the storage. If an error occurs during the removal, it
// logs the error and returns an Internal status. If the operation is successful, it returns an empty response.
func (g *GophkeeperServer) RemoveUserCredentials(ctx context.Context, in *proto.RemoveUserCredentialsRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if in.Id == "" </span><span class="cov0" title="0">{
                logger.Log.Error("you must provide credentials id")
                return nil, status.Errorf(codes.InvalidArgument, "you must provide credentials id")
        }</span>

        <span class="cov0" title="0">credID, err := strconv.ParseInt(in.Id, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("invalid credentials id")
                return nil, status.Errorf(codes.InvalidArgument, "invalid credentials id")
        }</span>

        <span class="cov0" title="0">if err = g.Storage.RemoveUserCredential(ctx, credID); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error remove user credentials", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error remove user credentials")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package handlers

import (
        "context"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/pkg/aes"
        "github.com/Vidkin/gophkeeper/proto"
)

// RegisterUser registers a new user in the system.
//
// Parameters:
//   - ctx: The context for the gRPC call, which may contain user identification information.
//   - in: A pointer to the proto.RegisterUserRequest structure, which contains the user's credentials
//     (login and password) for registration.
//
// Returns:
//   - A pointer to an empty proto.Empty response indicating successful registration of the user.
//   - An error if the operation fails, for example, if the user login or password is invalid, if the
//     user already exists, or if there is an internal error while encrypting the password or adding the
//     user to the storage.
//
// The function first checks if the user login and password are provided in the request. If either is
// missing, it logs an error and returns an InvalidArgument status. It then checks if the user already
// exists in the storage. If the user exists, it logs an error and returns an AlreadyExists status. If
// the user does not exist, it encrypts the password using AES encryption. If the encryption fails, it
// logs the error and returns an Internal status. Finally, if the user is successfully added to the
// storage, it returns an empty response.
func (g *GophkeeperServer) RegisterUser(ctx context.Context, in *proto.RegisterUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if in.Credentials.Login == "" </span><span class="cov0" title="0">{
                logger.Log.Error("invalid user login")
                return nil, status.Errorf(codes.InvalidArgument, "invalid user login")
        }</span>
        <span class="cov0" title="0">if in.Credentials.Password == "" </span><span class="cov0" title="0">{
                logger.Log.Error("invalid user password")
                return nil, status.Errorf(codes.InvalidArgument, "invalid user password")
        }</span>

        <span class="cov0" title="0">_, err := g.Storage.GetUser(ctx, in.Credentials.Login)
        if err == nil </span><span class="cov0" title="0">{
                logger.Log.Error("user already exists")
                return nil, status.Errorf(codes.AlreadyExists, "user already exists")
        }</span>

        <span class="cov0" title="0">encPwd, err := aes.Encrypt(g.DatabaseKey, in.Credentials.Password)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error encrypt password", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error encrypt password")
        }</span>

        <span class="cov0" title="0">if err := g.Storage.AddUser(ctx, in.Credentials.Login, encPwd); err != nil </span><span class="cov0" title="0">{
                logger.Log.Error("error create user", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "error create user")
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package logger provides a simple logging utility using the Zap logging library.
//
// This package allows for the initialization of a logger with a specified log level.
// It uses the Zap library to provide structured and performant logging capabilities.
package logger

import (
        "go.uber.org/zap"
)

// Log is the global logger instance that can be used throughout the application.
var Log *zap.Logger = zap.NewNop()

// Initialize sets up the logger with the specified log level.
//
// Parameters:
//   - logLevel: A string representing the desired log level (e.g., "debug", "info", "warn", "error").
//
// Returns:
//   - An error if the log level is invalid or if there is an issue during logger initialization.
//   - nil if the logger is successfully initialized.
//
// The function parses the provided log level and configures the logger accordingly. It creates a
// production logger with the specified log level. If the logger is successfully built, it replaces
// the global Log variable with the new logger instance. The logger is set to sync its output before
// the function returns, ensuring that all log entries are flushed.
func Initialize(logLevel string) error <span class="cov0" title="0">{
        lvl, err := zap.ParseAtomicLevel(logLevel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cfg := zap.NewProductionConfig()
        cfg.Level = lvl

        logger, err := cfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer logger.Sync()

        Log = logger
        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package storage provides functionality for interacting with storage services.
//
// This package includes the NewMinioStorage function, which initializes a MinIO client for object storage.
package storage

import (
        "context"
        "crypto/tls"
        "io"
        "net/http"

        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"

        "github.com/Vidkin/gophkeeper/internal/logger"
)

const MinioBucketName = "gophkeeper"

type MinioClientInterface interface {
        MakeBucket(ctx context.Context, bucketName string, opts minio.MakeBucketOptions) error
        BucketExists(ctx context.Context, bucketName string) (bool, error)
        GetObject(ctx context.Context, bucketName, objectName string, opts minio.GetObjectOptions) (*minio.Object, error)
        RemoveObject(ctx context.Context, bucketName, objectName string, opts minio.RemoveObjectOptions) error
        PutObject(ctx context.Context, bucketName, objectName string, reader io.Reader, objectSize int64, opts minio.PutObjectOptions) (info minio.UploadInfo, err error)
}

var s minio.Client

// NewMinioStorage initializes a new MinIO client and creates a bucket if it does not already exist.
//
// Parameters:
//   - endpoint: A string representing the MinIO server endpoint (e.g., "localhost:9000").
//   - accessKeyID: A string representing the access key ID for MinIO authentication.
//   - secretAccessKey: A string representing the secret access key for MinIO authentication.
//
// Returns:
//   - A pointer to a minio.Client instance for interacting with the MinIO storage.
//   - An error if the client could not be created or if there was an issue creating the bucket.
//
// The function creates a new MinIO client with the provided credentials and a secure connection.
// It then attempts to create a bucket with the name defined by MinioBucketName. If the bucket
// already exists, it logs an informational message. If the bucket creation fails for any other
// reason, it returns an error. If successful, it returns the MinIO client instance.
func NewMinioStorage(endpoint, accessKeyID, secretAccessKey string, minioClient MinioClientInterface) (MinioClientInterface, error) <span class="cov8" title="1">{
        ctx := context.Background()
        if minioClient == nil </span><span class="cov0" title="0">{
                var err error
                minioClient, err = minio.New(endpoint, &amp;minio.Options{
                        Creds:  credentials.NewStaticV4(accessKeyID, secretAccessKey, ""),
                        Secure: true,
                        Transport: &amp;http.Transport{
                                TLSClientConfig: &amp;tls.Config{
                                        InsecureSkipVerify: true,
                                },
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">err := minioClient.MakeBucket(ctx, MinioBucketName, minio.MakeBucketOptions{})
        if err != nil </span><span class="cov8" title="1">{
                exists, errBucketExists := minioClient.BucketExists(ctx, MinioBucketName)
                if errBucketExists == nil &amp;&amp; exists </span><span class="cov8" title="1">{
                        logger.Log.Info("bucket already created")
                }</span> else<span class="cov8" title="1"> {
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                logger.Log.Info("successfully created bucket")
        }</span>

        <span class="cov8" title="1">return minioClient, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package storage provides functionality for interacting with a PostgreSQL database.
//
// This package includes the PostgresStorage struct, which implements methods for managing users, files,
// notes, bank cards, and user credentials in a PostgreSQL database.
package storage

import (
        "context"
        "database/sql"
        "embed"
        "errors"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/golang-migrate/migrate/v4/source/iofs"
        _ "github.com/jackc/pgx/v5/stdlib"
        "go.uber.org/zap"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/internal/model"
)

//go:embed migrations/*.sql
var Migrations embed.FS

// PostgresStorage represents a storage backend using PostgreSQL.
type PostgresStorage struct {
        Conn *sql.DB
}

// NewPostgresStorage initializes a new PostgresStorage instance and applies database migrations.
//
// Parameters:
//   - dbDSN: A string representing the Data Source Name (DSN) for connecting to the PostgreSQL database.
//
// Returns:
//   - A pointer to a PostgresStorage instance.
//   - An error if the connection to the database could not be established or if migrations fail.
//
// The function opens a connection to the PostgreSQL database, creates a migration instance, and applies
// any pending migrations. If successful, it returns a PostgresStorage instance with an active database connection.
func NewPostgresStorage(dbDSN string) (*PostgresStorage, error) <span class="cov8" title="1">{
        var p PostgresStorage
        db, err := sql.Open("pgx", dbDSN)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("error open sql connection", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("can't create postgres driver for migrations", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">d, err := iofs.New(Migrations, "migrations")
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("can't get migrations from FS", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">m, err := migrate.NewWithInstance("iofs", d, "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                logger.Log.Fatal("can't create new migrate instance", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := m.Up(); err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                logger.Log.Fatal("can't exec migrations", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov8" title="1">p.Conn = db
        return &amp;p, nil</span>
}

// Ping checks the connection to the PostgreSQL database.
//
// Parameters:
//   - ctx: The context for the operation.
//
// Returns:
//   - An error if the connection is not alive or if there is an issue with the database.
func (p *PostgresStorage) Ping(ctx context.Context) error <span class="cov8" title="1">{
        return p.Conn.PingContext(ctx)
}</span>

// Close closes the database connection.
//
// Returns:
//   - An error if there is an issue closing the connection.
func (p *PostgresStorage) Close() error <span class="cov8" title="1">{
        return p.Conn.Close()
}</span>

// AddUser adds a new user to the database.
//
// Parameters:
//   - ctx: The context for the operation.
//   - login: A string representing the user's login name.
//   - password: A string representing the user's password.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) AddUser(ctx context.Context, login, password string) error <span class="cov8" title="1">{
        _, err := p.Conn.ExecContext(ctx, "INSERT INTO users (login, password) VALUES ($1, $2)", login, password)
        return err
}</span>

// AddFile adds a new file or updates an existing file for a user.
//
// Parameters:
//   - ctx: The context for the operation.
//   - bucketName: A string representing the name of the bucket where the file is stored.
//   - fileName: A string representing the name of the file.
//   - description: A string providing additional information about the file.
//   - userID: An int64 representing the unique identifier of the user.
//   - fileSize: An int64 representing the size of the file in bytes.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) AddFile(ctx context.Context, bucketName, fileName, description string, userID int64, fileSize int64) error <span class="cov8" title="1">{
        var count int
        row := p.Conn.QueryRowContext(
                ctx,
                "SELECT count(*) FROM files WHERE file_name=$1 and user_id=$2",
                fileName, userID)
        if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                _, err := p.Conn.ExecContext(
                        ctx,
                        "UPDATE files SET file_size=$1, description=$2 WHERE file_name=$3", fileSize, description, fileName)
                return err
        }</span>

        <span class="cov8" title="1">_, err := p.Conn.ExecContext(
                ctx,
                "INSERT INTO files (user_id, bucket_name, file_name, file_size, description) VALUES ($1, $2, $3, $4, $5)",
                userID, bucketName, fileName, fileSize, description)
        return err</span>
}

// GetFile retrieves a file by its name from the database.
//
// Parameters:
//   - ctx: The context for the operation.
//   - fileName: A string representing the name of the file to retrieve.
//
// Returns:
//   - A pointer to a model.File instance containing the file information.
//   - An error if the operation fails or if the file is not found.
func (p *PostgresStorage) GetFile(ctx context.Context, fileName string) (*model.File, error) <span class="cov8" title="1">{
        row := p.Conn.QueryRowContext(
                ctx,
                "SELECT user_id, id, file_name, bucket_name, description, file_size, created_at FROM files WHERE file_name = $1",
                fileName)

        var f model.File
        if err := row.Scan(&amp;f.UserID, &amp;f.ID, &amp;f.FileName, &amp;f.BucketName, &amp;f.Description, &amp;f.FileSize, &amp;f.CreatedAt); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;f, nil</span>
}

// GetFiles retrieves all files associated with a user.
//
// Parameters:
//   - ctx: The context for the operation.
//   - userID: An int64 representing the unique identifier of the user.
//
// Returns:
//   - A slice of pointers to model.File instances containing the user's files.
//   - An error if the operation fails.
func (p *PostgresStorage) GetFiles(ctx context.Context, userID int64) ([]*model.File, error) <span class="cov8" title="1">{
        rows, err := p.Conn.QueryContext(
                ctx,
                "SELECT user_id, id, file_name, bucket_name, description, file_size, created_at id FROM files WHERE user_id = $1",
                userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func(rows *sql.Rows) </span><span class="cov8" title="1">{
                err = rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error close rows", zap.Error(err))
                }</span>
        }(rows)

        <span class="cov8" title="1">var files []*model.File
        for rows.Next() </span><span class="cov8" title="1">{
                var f model.File
                if err = rows.Scan(&amp;f.UserID, &amp;f.ID, &amp;f.FileName, &amp;f.BucketName, &amp;f.Description, &amp;f.FileSize, &amp;f.CreatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">files = append(files, &amp;f)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return files, nil</span>
}

// RemoveFile deletes a file from the database by its name.
//
// Parameters:
//   - ctx: The context for the operation.
//   - fileName: A string representing the name of the file to delete.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) RemoveFile(ctx context.Context, fileName string) error <span class="cov8" title="1">{
        _, err := p.Conn.ExecContext(ctx, "DELETE FROM files WHERE file_name = $1", fileName)
        return err
}</span>

// GetUser retrieves a user by their login from the database.
//
// Parameters:
//   - ctx: The context for the operation.
//   - login: A string representing the user's login name.
//
// Returns:
//   - A pointer to a model.User instance containing the user information.
//   - An error if the operation fails or if the user is not found.
func (p *PostgresStorage) GetUser(ctx context.Context, login string) (*model.User, error) <span class="cov8" title="1">{
        row := p.Conn.QueryRowContext(ctx, "SELECT login, password, id FROM users WHERE login = $1", login)

        var u model.User
        if err := row.Scan(&amp;u.Login, &amp;u.Password, &amp;u.ID); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;u, nil</span>
}

// AddUserCredentials adds new user credentials to the database.
//
// Parameters:
//   - ctx: The context for the operation.
//   - cred: A pointer to a model.Credentials instance containing the credentials to add.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) AddUserCredentials(ctx context.Context, cred *model.Credentials) error <span class="cov8" title="1">{
        _, err := p.Conn.ExecContext(
                ctx,
                "INSERT INTO user_credentials (login, password, description, user_id) VALUES ($1, $2, $3, $4)",
                cred.Login, cred.Password, cred.Description, cred.UserID)
        return err
}</span>

// GetUserCredentials retrieves all credentials associated with a user.
//
// Parameters:
//   - ctx: The context for the operation.
//   - userID: An int64 representing the unique identifier of the user.
//
// Returns:
//   - A slice of pointers to model.Credentials instances containing the user's credentials.
//   - An error if the operation fails.
func (p *PostgresStorage) GetUserCredentials(ctx context.Context, userID int64) ([]*model.Credentials, error) <span class="cov8" title="1">{
        rows, err := p.Conn.QueryContext(ctx, "SELECT id, user_id, login, password, description FROM user_credentials WHERE user_id = $1", userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func(rows *sql.Rows) </span><span class="cov8" title="1">{
                err = rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error close rows", zap.Error(err))
                }</span>
        }(rows)

        <span class="cov8" title="1">var creds []*model.Credentials
        for rows.Next() </span><span class="cov8" title="1">{
                var c model.Credentials
                if err = rows.Scan(&amp;c.ID, &amp;c.UserID, &amp;c.Login, &amp;c.Password, &amp;c.Description); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">creds = append(creds, &amp;c)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return creds, nil</span>
}

// GetUserCredential retrieves a specific user credential by its ID.
//
// Parameters:
//   - ctx: The context for the operation.
//   - id: An int64 representing the unique identifier of the credential.
//
// Returns:
//   - A pointer to a model.Credentials instance containing the credential information.
//   - An error if the operation fails or if the credential is not found.
func (p *PostgresStorage) GetUserCredential(ctx context.Context, id int64) (*model.Credentials, error) <span class="cov8" title="1">{
        row := p.Conn.QueryRowContext(ctx, "SELECT id, user_id, login, password, description FROM user_credentials WHERE id = $1", id)

        var cred model.Credentials
        if err := row.Scan(&amp;cred.ID, &amp;cred.UserID, &amp;cred.Login, &amp;cred.Password, &amp;cred.Description); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cred, nil</span>
}

// RemoveUserCredential deletes a user credential from the database by its ID.
//
// Parameters:
//   - ctx: The context for the operation.
//   - id: An int64 representing the unique identifier of the credential to delete.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) RemoveUserCredential(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := p.Conn.ExecContext(ctx, "DELETE FROM user_credentials WHERE id = $1", id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddNote adds a new note to the database.
//
// Parameters:
//   - ctx: The context for the operation.
//   - note: A pointer to a model.Note instance containing the note information to add.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) AddNote(ctx context.Context, note *model.Note) error <span class="cov8" title="1">{
        _, err := p.Conn.ExecContext(
                ctx,
                "INSERT INTO notes (text, description, user_id) VALUES ($1, $2, $3)",
                note.Text, note.Description, note.UserID)
        return err
}</span>

// GetNotes retrieves all notes associated with a user.
//
// Parameters:
//   - ctx: The context for the operation.
//   - userID: An int64 representing the unique identifier of the user.
//
// Returns:
//   - A slice of pointers to model.Note instances containing the user's notes.
//   - An error if the operation fails.
func (p *PostgresStorage) GetNotes(ctx context.Context, userID int64) ([]*model.Note, error) <span class="cov8" title="1">{
        rows, err := p.Conn.QueryContext(ctx, "SELECT id, user_id, text, description FROM notes WHERE user_id = $1", userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func(rows *sql.Rows) </span><span class="cov8" title="1">{
                err = rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error close rows", zap.Error(err))
                }</span>
        }(rows)

        <span class="cov8" title="1">var notes []*model.Note
        for rows.Next() </span><span class="cov8" title="1">{
                var n model.Note
                if err = rows.Scan(&amp;n.ID, &amp;n.UserID, &amp;n.Text, &amp;n.Description); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">notes = append(notes, &amp;n)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return notes, nil</span>
}

// GetNote retrieves a specific note by its ID from the database.
//
// Parameters:
//   - ctx: The context for the operation
//   - id: An int64 representing the unique identifier of the note to retrieve.
//
// Returns:
//   - A pointer to a model.Note instance containing the note information.
//   - An error if the operation fails or if the note is not found.
func (p *PostgresStorage) GetNote(ctx context.Context, id int64) (*model.Note, error) <span class="cov8" title="1">{
        row := p.Conn.QueryRowContext(ctx, "SELECT id, user_id, text, description FROM notes WHERE id = $1", id)

        var note model.Note
        if err := row.Scan(&amp;note.ID, &amp;note.UserID, &amp;note.Text, &amp;note.Description); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;note, nil</span>
}

// RemoveNote deletes a note from the database by its ID.
//
// Parameters:
//   - ctx: The context for the operation.
//   - id: An int64 representing the unique identifier of the note to delete.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) RemoveNote(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := p.Conn.ExecContext(ctx, "DELETE FROM notes WHERE id = $1", id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddCard adds a new bank card to the database.
//
// Parameters:
//   - ctx: The context for the operation.
//   - card: A pointer to a model.BankCard instance containing the card information to add.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) AddCard(ctx context.Context, card *model.BankCard) error <span class="cov8" title="1">{
        _, err := p.Conn.ExecContext(
                ctx,
                "INSERT INTO bank_cards (user_id, card_number, expiration_date, cvv, owner, description) "+
                        "VALUES ($1, $2, $3, $4, $5, $6)", card.UserID, card.Number, card.ExpireDate, card.CVV, card.Owner, card.Description)
        return err
}</span>

// GetBankCards retrieves all bank cards associated with a user.
//
// Parameters:
//   - ctx: The context for the operation.
//   - userID: An int64 representing the unique identifier of the user.
//
// Returns:
//   - A slice of pointers to model.BankCard instances containing the user's bank cards.
//   - An error if the operation fails.
func (p *PostgresStorage) GetBankCards(ctx context.Context, userID int64) ([]*model.BankCard, error) <span class="cov8" title="1">{
        rows, err := p.Conn.QueryContext(ctx, "SELECT id, user_id, owner, card_number, expiration_date, cvv, description FROM bank_cards WHERE user_id = $1", userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer func(rows *sql.Rows) </span><span class="cov8" title="1">{
                err = rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error close rows", zap.Error(err))
                }</span>
        }(rows)

        <span class="cov8" title="1">var cards []*model.BankCard
        for rows.Next() </span><span class="cov8" title="1">{
                var b model.BankCard
                if err = rows.Scan(&amp;b.ID, &amp;b.UserID, &amp;b.Owner, &amp;b.Number, &amp;b.ExpireDate, &amp;b.CVV, &amp;b.Description); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">cards = append(cards, &amp;b)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cards, nil</span>
}

// GetBankCard retrieves a specific bank card by its ID from the database.
//
// Parameters:
//   - ctx: The context for the operation.
//   - id: An int64 representing the unique identifier of the bank card to retrieve.
//
// Returns:
//   - A pointer to a model.BankCard instance containing the bank card information.
//   - An error if the operation fails or if the bank card is not found.
func (p *PostgresStorage) GetBankCard(ctx context.Context, id int64) (*model.BankCard, error) <span class="cov8" title="1">{
        row := p.Conn.QueryRowContext(ctx, "SELECT id, user_id, owner, card_number, expiration_date, cvv, description FROM bank_cards WHERE id = $1", id)

        var card model.BankCard
        if err := row.Scan(&amp;card.ID, &amp;card.UserID, &amp;card.Owner, &amp;card.Number, &amp;card.ExpireDate, &amp;card.CVV, &amp;card.Description); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;card, nil</span>
}

// RemoveBankCard deletes a bank card from the database by its ID.
//
// Parameters:
//   - ctx: The context for the operation.
//   - id: An int64 representing the unique identifier of the bank card to delete.
//
// Returns:
//   - An error if the operation fails.
func (p *PostgresStorage) RemoveBankCard(ctx context.Context, id int64) error <span class="cov8" title="1">{
        _, err := p.Conn.ExecContext(ctx, "DELETE FROM bank_cards WHERE id = $1", id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package aes provides functionality for AES encryption and decryption.
//
// This package includes the Decrypt function, which decrypts a base64-encoded string
// using the AES algorithm in GCM mode.
package aes

import (
        "crypto/aes"
        "crypto/cipher"
        "encoding/base64"
        "fmt"
)

// Decrypt decrypts a base64-encoded string using the provided AES key.
//
// Parameters:
//   - key: A string representing the AES key used for decryption. The key must be either
//     16, 24, or 32 bytes long, corresponding to AES-128, AES-192, or AES-256.
//   - src: A base64-encoded string representing the encrypted data, which includes the nonce
//     used during encryption.
//
// Returns:
//   - A string containing the decrypted plaintext.
//   - An error if the decryption process fails, including issues with the key length,
//     base64 decoding, or GCM decryption.
//
// The function first decodes the base64-encoded input string. It then creates a new AES cipher
// block using the provided key. A GCM (Galois/Counter Mode) cipher is created for decryption.
// The function extracts the nonce from the beginning of the decoded data and separates the
// ciphertext. Finally, it attempts to decrypt the ciphertext using the nonce and returns the
// resulting plaintext. If any step fails, an appropriate error is returned.
func Decrypt(key, src string) (string, error) <span class="cov8" title="1">{
        data, err := base64.StdEncoding.DecodeString(src)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher([]byte(key))
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov0" title="0">{
                return "", fmt.Errorf("can't extract nonce")
        }</span>
        <span class="cov8" title="1">nonce, cipherText := data[:nonceSize], data[nonceSize:]

        res, err := gcm.Open(nil, nonce, cipherText, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(res), nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package aes provides functionality for AES encryption and decryption.
//
// This package includes the Encrypt function, which encrypts a plaintext string
// using the AES algorithm in GCM mode.
package aes

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "io"
)

// Encrypt encrypts a plaintext string using the provided AES key.
//
// Parameters:
//   - key: A string representing the AES key used for encryption. The key must be either
//     16, 24, or 32 bytes long, corresponding to AES-128, AES-192, or AES-256.
//   - src: A string representing the plaintext data to be encrypted.
//
// Returns:
//   - A base64-encoded string containing the encrypted data, which includes the nonce
//     used during encryption.
//   - An error if the encryption process fails, including issues with the key length,
//     GCM initialization, or random nonce generation.
//
// The function creates a new AES cipher block using the provided key and initializes a GCM
// (Galois/Counter Mode) cipher for encryption. It generates a random nonce of the appropriate
// size and uses it to encrypt the plaintext. The resulting ciphertext, which includes the nonce,
// is then base64-encoded and returned. If any step fails, an appropriate error is returned.
func Encrypt(key, src string) (string, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher([]byte(key))
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">cipherText := gcm.Seal(nonce, nonce, []byte(src), nil)
        return base64.StdEncoding.EncodeToString(cipherText), nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Package cert provides functionality for creating and saving
X.509 certificates and corresponding private keys in PEM format.
*/
package cert

import (
        "bytes"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "math/big"
        "net"
        "os"
        "time"
)

// saveFile saves data to a file at the specified path.
// Parameters:
//   - path: the path to the file where data will be saved.
//   - data: the data to be saved.
//
// Returns an error if the saving fails.
func saveFile(path string, data []byte) error <span class="cov8" title="1">{
        return os.WriteFile(path, data, 0755)
}</span>

// createX509Certificate creates a new X.509 certificate and the corresponding
// private RSA key. The certificate will be valid for the IP addresses
// 127.0.0.1 and ::1, and will have a validity period of 10 years.
// Parameters:
//   - organization: the name of the organization for which the certificate is created.
//   - country: the country where the organization is registered.
//
// Returns the private key, certificate bytes, and an error if the certificate creation fails.
func createX509Certificate(organization, country string) (*rsa.PrivateKey, []byte, error) <span class="cov8" title="1">{
        // создаём шаблон сертификата
        cert := &amp;x509.Certificate{
                // указываем уникальный номер сертификата
                SerialNumber: big.NewInt(1),
                // заполняем базовую информацию о владельце сертификата
                Subject: pkix.Name{
                        Organization: []string{organization},
                        Country:      []string{country},
                },
                // разрешаем использование сертификата для 127.0.0.1 и ::1
                IPAddresses: []net.IP{net.IPv4(127, 0, 0, 1), net.IPv6loopback},
                // сертификат верен, начиная со времени создания
                NotBefore: time.Now(),
                // время жизни сертификата — 10 лет
                NotAfter:     time.Now().AddDate(10, 0, 0),
                SubjectKeyId: []byte{1, 2, 3, 4, 6},
                // устанавливаем использование ключа для цифровой подписи,
                // а также клиентской и серверной авторизации
                ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
                KeyUsage:    x509.KeyUsageDigitalSignature,
        }

        // создаём новый приватный RSA-ключ длиной 4096 бит
        // обратите внимание, что для генерации ключа и сертификата
        // используется rand.Reader в качестве источника случайных данных
        privateKey, err := rsa.GenerateKey(rand.Reader, 4096)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // создаём сертификат x.509
        <span class="cov8" title="1">certBytes, err := x509.CreateCertificate(rand.Reader, cert, cert, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return privateKey, certBytes, nil</span>
}

// createCertPEM encodes the certificate in PEM format.
// Parameters:
//   - certBytes: the bytes of the certificate to encode.
//
// Returns a buffer with the encoded certificate and an error if encoding fails.
func createCertPEM(certBytes []byte) (bytes.Buffer, error) <span class="cov8" title="1">{
        // кодируем сертификат и ключ в формате PEM, который
        // используется для хранения и обмена криптографическими ключами
        var certPEM bytes.Buffer
        err := pem.Encode(&amp;certPEM, &amp;pem.Block{
                Type:  "CERTIFICATE",
                Bytes: certBytes,
        })
        return certPEM, err
}</span>

// createPrivateKeyPEM encodes the private key in PEM format.
// Parameters:
//   - privateKey: the private RSA key to encode.
//
// Returns a buffer with the encoded private key and an error if encoding fails.
func createPrivateKeyPEM(privateKey *rsa.PrivateKey) (bytes.Buffer, error) <span class="cov8" title="1">{
        var privateKeyPEM bytes.Buffer
        err := pem.Encode(&amp;privateKeyPEM, &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        })
        return privateKeyPEM, err
}</span>

// createAndSave is the entry point of the program. It creates an X.509 certificate,
// generates the corresponding private key, and saves them to files
// cert.pem and privateKey.pem.
// Parameters:
//   - organization: the name of the organization for which the certificate is created.
//   - country: the country where the organization is registered.
//   - pathCertPEM: path where to save cert pem file.
//   - pathPrivateKeyPEM: path where to save private key pem file.
//
// Returns an error if operation fails.
func createAndSave(organization, country, pathCertPEM, pathPrivateKeyPEM string) error <span class="cov8" title="1">{
        privateKey, certBytes, err := createX509Certificate(organization, country)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">certPEM, err := createCertPEM(certBytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">privateKeyPEM, err := createPrivateKeyPEM(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = saveFile(pathCertPEM, certPEM.Bytes())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = saveFile(pathPrivateKeyPEM, privateKeyPEM.Bytes())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Package hash provides functionality for generating cryptographic hashes.
//
// This package includes the GetHashSHA256 function, which computes a SHA-256 hash
// of the provided data combined with a key.
package hash

import "crypto/sha256"

// GetHashSHA256 computes the SHA-256 hash of the given data combined with a key.
//
// Parameters:
//   - key: A string representing the key to be included in the hash computation.
//   - data: A byte slice containing the data to be hashed.
//
// Returns:
//   - A byte slice containing the resulting SHA-256 hash.
//
// The function creates a new SHA-256 hash instance and writes the provided data
// and key into it. It then computes the final hash and returns it as a byte slice.
// This function can be used for generating secure hashes for data integrity
// verification or authentication purposes.
func GetHashSHA256(key string, data []byte) []byte <span class="cov8" title="1">{
        h := sha256.New()
        h.Write(data)
        h.Write([]byte(key))
        return h.Sum(nil)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Package interceptors provides gRPC interceptors for handling requests and responses.
//
// This package includes the HashInterceptor function, which verifies the integrity of
// incoming requests by comparing a provided hash with a computed hash of the request data.
package interceptors

import (
        "bytes"
        "context"
        "encoding/base64"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"

        "github.com/Vidkin/gophkeeper/internal/logger"
        "github.com/Vidkin/gophkeeper/pkg/hash"
)

// HashInterceptor returns a gRPC unary server interceptor that verifies the SHA-256 hash
// of incoming requests against a provided key.
//
// Parameters:
//   - key: A string representing the key used for hash computation. If the key is empty,
//     the interceptor will skip hash verification.
//
// The interceptor extracts the "HashSHA256" metadata from the incoming context and decodes
// it from a base64 string. It then marshals the request into a byte slice and computes
// the SHA-256 hash using the provided key. If the computed hash does not match the
// provided hash, an error is returned, indicating that the hashes do not match.
//
// Returns:
//   - A function that implements the gRPC UnaryHandler signature, which processes the
//     request if the hash verification is successful, or returns an error if it fails.
func HashInterceptor(key string) func(context.Context, interface{}, *grpc.UnaryServerInfo, grpc.UnaryHandler) (interface{}, error) <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                if key == "" </span><span class="cov8" title="1">{
                        return handler(ctx, req)
                }</span>

                <span class="cov8" title="1">var hEnc string
                if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov8" title="1">{
                        values := md.Get("HashSHA256")
                        if len(values) &gt; 0 </span><span class="cov8" title="1">{
                                hEnc = values[0]
                        }</span>
                }
                <span class="cov8" title="1">if len(hEnc) == 0 </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.InvalidArgument, "missing hash")
                }</span>

                <span class="cov8" title="1">hashA, err := base64.StdEncoding.DecodeString(hEnc)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Log.Error("error decode hash from base64 string", zap.Error(err))
                        return nil, status.Error(codes.Internal, "missing hash")
                }</span>

                <span class="cov8" title="1">var data []byte
                if msg, ok := req.(proto.Message); ok </span><span class="cov8" title="1">{
                        data, err = proto.Marshal(msg)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Log.Error("failed to marshal request: %v", zap.Error(err))
                                return nil, status.Errorf(codes.Internal, "failed to marshal request")
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, status.Errorf(codes.Internal, "failed to get proto.Message")
                }</span>

                <span class="cov8" title="1">hashB := hash.GetHashSHA256(key, data)
                if !bytes.Equal(hashA, hashB) </span><span class="cov8" title="1">{
                        logger.Log.Error("hashes don't match")
                        return nil, status.Errorf(codes.InvalidArgument, "hashes don't match")
                }</span>

                <span class="cov8" title="1">return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Package interceptors provides gRPC interceptors for handling requests and responses.
//
// This package includes the LoggingInterceptor function, which logs the details of
// incoming requests and their corresponding responses.
package interceptors

import (
        "context"
        "time"

        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
)

// LoggingInterceptor is a gRPC unary server interceptor that logs the details of
// incoming requests and their responses, including the method name, duration,
// and response status.
//
// Parameters:
//   - ctx: A context.Context for managing request-scoped values and cancellation.
//   - req: An interface{} representing the incoming request message.
//   - info: A pointer to grpc.UnaryServerInfo containing information about the method being called.
//   - handler: A grpc.UnaryHandler that processes the request and returns a response.
//
// Returns:
//   - An interface{} containing the response from the handler.
//   - An error if the handler returns an error.
//
// The interceptor records the start time of the request, invokes the handler to process
// the request, and calculates the duration of the request. It then logs the method name,
// duration, and response status. If an error occurs during the handling of the request,
// the error status is logged instead. This interceptor is useful for monitoring and
// debugging gRPC services by providing insights into request processing times and outcomes.
func LoggingInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov8" title="1">{
        startTime := time.Now()
        itf, err := handler(ctx, req)
        duration := time.Since(startTime)

        var respStatus string
        if err != nil </span><span class="cov8" title="1">{
                st, ok := status.FromError(err)
                if ok </span><span class="cov8" title="1">{
                        respStatus = st.Code().String()
                }</span> else<span class="cov8" title="1"> {
                        respStatus = err.Error()
                }</span>
        } else<span class="cov8" title="1"> {
                respStatus = codes.OK.String()
        }</span>
        <span class="cov8" title="1">logger.Log.Info(
                "Request data",
                zap.String("method", info.FullMethod),
                zap.Duration("duration", duration),
        )
        logger.Log.Info(
                "Response data",
                zap.String("status", respStatus),
        )
        return itf, err</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package interceptors provides gRPC interceptors for handling requests and responses.
//
// This package includes the ValidateToken function, which validates JWT tokens for
// incoming requests to secure gRPC methods.
package interceptors

import (
        "context"
        "fmt"

        "github.com/golang-jwt/jwt/v4"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"

        "github.com/Vidkin/gophkeeper/internal/logger"
        jwtPKG "github.com/Vidkin/gophkeeper/pkg/jwt"
)

type contextKey string

const (
        GrpcRegisterUserMethod            = "/gophkeeper.Gophkeeper/RegisterUser"
        GrpcAuthorizeMethod               = "/gophkeeper.Gophkeeper/Authorize"
        GrpcEchoMethod                    = "/gophkeeper.Gophkeeper/Echo"
        UserID                 contextKey = "UserID"
)

// ValidateToken returns a gRPC unary server interceptor that validates JWT tokens
// for incoming requests, allowing access to secured methods based on the token's validity.
//
// Parameters:
//   - key: A string representing the secret key used for signing the JWT tokens.
//
// The interceptor checks if the incoming request's method is one of the public methods
// (RegisterUser, Authorize, or Echo). If it is, or if the key is empty, the interceptor
// allows the request to proceed without validation. Otherwise, it extracts the token from
// the metadata of the incoming context and attempts to parse it using the provided key.
//
// Returns:
//   - A function that implements the gRPC UnaryHandler signature, which processes the
//     request if the token is valid, or returns an error if the token is missing or invalid.
//
// If the token is successfully parsed and validated, the interceptor extracts the UserID
// from the claims and stores it in the context for further use in the request handling.
func ValidateToken(key string) func(context.Context, interface{}, *grpc.UnaryServerInfo, grpc.UnaryHandler) (interface{}, error) <span class="cov8" title="1">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov8" title="1">{
                if info.FullMethod == GrpcRegisterUserMethod ||
                        info.FullMethod == GrpcAuthorizeMethod ||
                        info.FullMethod == GrpcEchoMethod </span><span class="cov8" title="1">{
                        return handler(ctx, req)
                }</span>
                <span class="cov8" title="1">if key == "" </span><span class="cov0" title="0">{
                        return handler(ctx, req)
                }</span>

                <span class="cov8" title="1">var tokenString string
                if md, ok := metadata.FromIncomingContext(ctx); ok </span><span class="cov8" title="1">{
                        values := md.Get("token")
                        if len(values) &gt; 0 </span><span class="cov8" title="1">{
                                tokenString = values[0]
                        }</span>
                }
                <span class="cov8" title="1">if len(tokenString) == 0 </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.PermissionDenied, "missing token")
                }</span>

                <span class="cov8" title="1">claims := &amp;jwtPKG.Claims{}
                token, err := jwt.ParseWithClaims(tokenString, claims,
                        func(t *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        logger.Log.Error("unexpected signing method")
                                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                                }</span>
                                <span class="cov8" title="1">return []byte(key), nil</span>
                        })

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        logger.Log.Error("error parse claims", zap.Error(err))
                        return nil, status.Errorf(codes.PermissionDenied, "error parse claims")
                }</span>

                <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                        logger.Log.Error("token  is not valid")
                        return nil, status.Errorf(codes.PermissionDenied, "token is not valid")
                }</span>

                <span class="cov8" title="1">ctx = context.WithValue(ctx, UserID, claims.UserID)
                return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package jwt provides functionality for creating and managing JSON Web Tokens (JWT).
//
// This package includes the Claims struct and the BuildJWTString function for generating
// signed JWTs with user-specific claims.
package jwt

import (
        "time"

        "github.com/golang-jwt/jwt/v4"
)

// Claims represents the custom claims for the JWT, including registered claims
// and a UserID field.
type Claims struct {
        jwt.RegisteredClaims
        UserID int64
}

// TokenExpireTime defines the duration for which the JWT is valid.
const TokenExpireTime = time.Hour * 1

// BuildJWTString generates a signed JWT string for a given user ID using the provided secret key.
//
// Parameters:
//   - secretKey: A string representing the secret key used for signing the JWT.
//   - userID: An int64 representing the user ID to be included in the JWT claims.
//
// Returns:
//   - A string containing the signed JWT.
//   - An error if the token could not be created or signed.
//
// The function creates a new JWT with claims that include an expiration time set to
// one hour from the current time and the specified user ID. It then signs the token
// using the provided secret key and returns the resulting token string. If any error
// occurs during the signing process, it returns an error.
func BuildJWTString(secretKey string, userID int64) (string, error) <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, Claims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(TokenExpireTime)),
                },
                UserID: userID,
        })

        tokenString, err := token.SignedString([]byte(secretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.1
//         protoc        v5.28.3
// source: proto/gophkeeper.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Credentials struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Login       string `protobuf:"bytes,2,opt,name=login,proto3" json:"login,omitempty"`
        Password    string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
        Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *Credentials) Reset() <span class="cov0" title="0">{
        *x = Credentials{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Credentials) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Credentials) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Credentials) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Credentials.ProtoReflect.Descriptor instead.
func (*Credentials) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Credentials) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Credentials) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Credentials) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Credentials) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Note struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Text        string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *Note) Reset() <span class="cov0" title="0">{
        *x = Note{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Note) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Note) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Note) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Note.ProtoReflect.Descriptor instead.
func (*Note) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Note) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Note) GetText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Text
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Note) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Credentials *Credentials `protobuf:"bytes,1,opt,name=credentials,proto3" json:"credentials,omitempty"`
}

func (x *RegisterUserRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterUserRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RegisterUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterUserRequest.ProtoReflect.Descriptor instead.
func (*RegisterUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{2}
}</span>

func (x *RegisterUserRequest) GetCredentials() *Credentials <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Credentials
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AuthorizeRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Credentials *Credentials `protobuf:"bytes,1,opt,name=credentials,proto3" json:"credentials,omitempty"`
}

func (x *AuthorizeRequest) Reset() <span class="cov0" title="0">{
        *x = AuthorizeRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AuthorizeRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AuthorizeRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AuthorizeRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AuthorizeRequest.ProtoReflect.Descriptor instead.
func (*AuthorizeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{3}
}</span>

func (x *AuthorizeRequest) GetCredentials() *Credentials <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Credentials
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AuthorizeResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *AuthorizeResponse) Reset() <span class="cov0" title="0">{
        *x = AuthorizeResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AuthorizeResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AuthorizeResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AuthorizeResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AuthorizeResponse.ProtoReflect.Descriptor instead.
func (*AuthorizeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{4}
}</span>

func (x *AuthorizeResponse) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AddUserCredentialsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Credentials *Credentials `protobuf:"bytes,1,opt,name=credentials,proto3" json:"credentials,omitempty"`
}

func (x *AddUserCredentialsRequest) Reset() <span class="cov0" title="0">{
        *x = AddUserCredentialsRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddUserCredentialsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddUserCredentialsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddUserCredentialsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddUserCredentialsRequest.ProtoReflect.Descriptor instead.
func (*AddUserCredentialsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{5}
}</span>

func (x *AddUserCredentialsRequest) GetCredentials() *Credentials <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Credentials
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetUserCredentialsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetUserCredentialsRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserCredentialsRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserCredentialsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserCredentialsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserCredentialsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserCredentialsRequest.ProtoReflect.Descriptor instead.
func (*GetUserCredentialsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{6}
}</span>

type GetUserCredentialsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Credentials []*Credentials `protobuf:"bytes,1,rep,name=credentials,proto3" json:"credentials,omitempty"`
}

func (x *GetUserCredentialsResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserCredentialsResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserCredentialsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserCredentialsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserCredentialsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserCredentialsResponse.ProtoReflect.Descriptor instead.
func (*GetUserCredentialsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetUserCredentialsResponse) GetCredentials() []*Credentials <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Credentials
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetUserCredentialRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetUserCredentialRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserCredentialRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserCredentialRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserCredentialRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserCredentialRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserCredentialRequest.ProtoReflect.Descriptor instead.
func (*GetUserCredentialRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetUserCredentialRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserCredentialResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Credentials *Credentials `protobuf:"bytes,1,opt,name=credentials,proto3" json:"credentials,omitempty"`
}

func (x *GetUserCredentialResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserCredentialResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserCredentialResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserCredentialResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserCredentialResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserCredentialResponse.ProtoReflect.Descriptor instead.
func (*GetUserCredentialResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetUserCredentialResponse) GetCredentials() *Credentials <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Credentials
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddNoteRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Note *Note `protobuf:"bytes,1,opt,name=note,proto3" json:"note,omitempty"`
}

func (x *AddNoteRequest) Reset() <span class="cov0" title="0">{
        *x = AddNoteRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddNoteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddNoteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddNoteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddNoteRequest.ProtoReflect.Descriptor instead.
func (*AddNoteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{10}
}</span>

func (x *AddNoteRequest) GetNote() *Note <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Note
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetNotesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetNotesRequest) Reset() <span class="cov0" title="0">{
        *x = GetNotesRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetNotesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetNotesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetNotesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetNotesRequest.ProtoReflect.Descriptor instead.
func (*GetNotesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{11}
}</span>

type GetNotesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Notes []*Note `protobuf:"bytes,1,rep,name=notes,proto3" json:"notes,omitempty"`
}

func (x *GetNotesResponse) Reset() <span class="cov0" title="0">{
        *x = GetNotesResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetNotesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetNotesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetNotesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetNotesResponse.ProtoReflect.Descriptor instead.
func (*GetNotesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetNotesResponse) GetNotes() []*Note <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Notes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetNoteRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetNoteRequest) Reset() <span class="cov0" title="0">{
        *x = GetNoteRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetNoteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetNoteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetNoteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetNoteRequest.ProtoReflect.Descriptor instead.
func (*GetNoteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{13}
}</span>

func (x *GetNoteRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetNoteResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Note *Note `protobuf:"bytes,1,opt,name=note,proto3" json:"note,omitempty"`
}

func (x *GetNoteResponse) Reset() <span class="cov0" title="0">{
        *x = GetNoteResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetNoteResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetNoteResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetNoteResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetNoteResponse.ProtoReflect.Descriptor instead.
func (*GetNoteResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{14}
}</span>

func (x *GetNoteResponse) GetNote() *Note <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Note
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RemoveNoteRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *RemoveNoteRequest) Reset() <span class="cov0" title="0">{
        *x = RemoveNoteRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RemoveNoteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveNoteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveNoteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveNoteRequest.ProtoReflect.Descriptor instead.
func (*RemoveNoteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{15}
}</span>

func (x *RemoveNoteRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type EchoRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *EchoRequest) Reset() <span class="cov0" title="0">{
        *x = EchoRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EchoRequest) String() string <span class="cov8" title="1">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EchoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EchoRequest) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[16]
        if x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EchoRequest.ProtoReflect.Descriptor instead.
func (*EchoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{16}
}</span>

func (x *EchoRequest) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type EchoResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *EchoResponse) Reset() <span class="cov0" title="0">{
        *x = EchoResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *EchoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EchoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EchoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EchoResponse.ProtoReflect.Descriptor instead.
func (*EchoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{17}
}</span>

func (x *EchoResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BankCard struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Number      string `protobuf:"bytes,2,opt,name=number,proto3" json:"number,omitempty"`
        ExpireDate  string `protobuf:"bytes,3,opt,name=expireDate,proto3" json:"expireDate,omitempty"`
        Cvv         string `protobuf:"bytes,4,opt,name=cvv,proto3" json:"cvv,omitempty"`
        Owner       string `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
        Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *BankCard) Reset() <span class="cov0" title="0">{
        *x = BankCard{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BankCard) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BankCard) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BankCard) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BankCard.ProtoReflect.Descriptor instead.
func (*BankCard) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{18}
}</span>

func (x *BankCard) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BankCard) GetNumber() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Number
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BankCard) GetExpireDate() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpireDate
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BankCard) GetCvv() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cvv
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BankCard) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *BankCard) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AddBankCardRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Card *BankCard `protobuf:"bytes,1,opt,name=card,proto3" json:"card,omitempty"`
}

func (x *AddBankCardRequest) Reset() <span class="cov0" title="0">{
        *x = AddBankCardRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddBankCardRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddBankCardRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddBankCardRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddBankCardRequest.ProtoReflect.Descriptor instead.
func (*AddBankCardRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{19}
}</span>

func (x *AddBankCardRequest) GetCard() *BankCard <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Card
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RemoveBankCardRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *RemoveBankCardRequest) Reset() <span class="cov0" title="0">{
        *x = RemoveBankCardRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RemoveBankCardRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveBankCardRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveBankCardRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveBankCardRequest.ProtoReflect.Descriptor instead.
func (*RemoveBankCardRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{20}
}</span>

func (x *RemoveBankCardRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RemoveUserCredentialsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *RemoveUserCredentialsRequest) Reset() <span class="cov0" title="0">{
        *x = RemoveUserCredentialsRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RemoveUserCredentialsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveUserCredentialsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveUserCredentialsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveUserCredentialsRequest.ProtoReflect.Descriptor instead.
func (*RemoveUserCredentialsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{21}
}</span>

func (x *RemoveUserCredentialsRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBankCardsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetBankCardsRequest) Reset() <span class="cov0" title="0">{
        *x = GetBankCardsRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBankCardsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBankCardsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBankCardsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBankCardsRequest.ProtoReflect.Descriptor instead.
func (*GetBankCardsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{22}
}</span>

type GetBankCardsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Cards []*BankCard `protobuf:"bytes,1,rep,name=cards,proto3" json:"cards,omitempty"`
}

func (x *GetBankCardsResponse) Reset() <span class="cov0" title="0">{
        *x = GetBankCardsResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[23]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBankCardsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBankCardsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBankCardsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[23]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBankCardsResponse.ProtoReflect.Descriptor instead.
func (*GetBankCardsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{23}
}</span>

func (x *GetBankCardsResponse) GetCards() []*BankCard <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Cards
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBankCardRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetBankCardRequest) Reset() <span class="cov0" title="0">{
        *x = GetBankCardRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[24]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBankCardRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBankCardRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBankCardRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[24]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBankCardRequest.ProtoReflect.Descriptor instead.
func (*GetBankCardRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{24}
}</span>

func (x *GetBankCardRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBankCardResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Card *BankCard `protobuf:"bytes,1,opt,name=card,proto3" json:"card,omitempty"`
}

func (x *GetBankCardResponse) Reset() <span class="cov0" title="0">{
        *x = GetBankCardResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[25]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetBankCardResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetBankCardResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetBankCardResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[25]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetBankCardResponse.ProtoReflect.Descriptor instead.
func (*GetBankCardResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{25}
}</span>

func (x *GetBankCardResponse) GetCard() *BankCard <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Card
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FileUploadRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FileName    string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
        Chunk       []byte `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        FileSize    int64  `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (x *FileUploadRequest) Reset() <span class="cov0" title="0">{
        *x = FileUploadRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[26]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FileUploadRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FileUploadRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FileUploadRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[26]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FileUploadRequest.ProtoReflect.Descriptor instead.
func (*FileUploadRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{26}
}</span>

func (x *FileUploadRequest) GetFileName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FileUploadRequest) GetChunk() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Chunk
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FileUploadRequest) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FileUploadRequest) GetFileSize() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type FileRemoveRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
}

func (x *FileRemoveRequest) Reset() <span class="cov0" title="0">{
        *x = FileRemoveRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[27]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FileRemoveRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FileRemoveRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FileRemoveRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[27]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FileRemoveRequest.ProtoReflect.Descriptor instead.
func (*FileRemoveRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{27}
}</span>

func (x *FileRemoveRequest) GetFileName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type FileUploadResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
        FileSize int64  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (x *FileUploadResponse) Reset() <span class="cov0" title="0">{
        *x = FileUploadResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[28]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FileUploadResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FileUploadResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FileUploadResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[28]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FileUploadResponse.ProtoReflect.Descriptor instead.
func (*FileUploadResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{28}
}</span>

func (x *FileUploadResponse) GetFileName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FileUploadResponse) GetFileSize() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type FileDownloadRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
}

func (x *FileDownloadRequest) Reset() <span class="cov0" title="0">{
        *x = FileDownloadRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[29]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FileDownloadRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FileDownloadRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FileDownloadRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[29]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FileDownloadRequest.ProtoReflect.Descriptor instead.
func (*FileDownloadRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{29}
}</span>

func (x *FileDownloadRequest) GetFileName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type FileDownloadResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Chunk       []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
        FileSize    int64  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
        Filename    string `protobuf:"bytes,3,opt,name=filename,proto3" json:"filename,omitempty"`
        Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *FileDownloadResponse) Reset() <span class="cov0" title="0">{
        *x = FileDownloadResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[30]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FileDownloadResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FileDownloadResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FileDownloadResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[30]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FileDownloadResponse.ProtoReflect.Descriptor instead.
func (*FileDownloadResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{30}
}</span>

func (x *FileDownloadResponse) GetChunk() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Chunk
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FileDownloadResponse) GetFileSize() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FileDownloadResponse) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FileDownloadResponse) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type File struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        FileName    string `protobuf:"bytes,2,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        CreatedAt   string `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        FileSize    int64  `protobuf:"varint,5,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (x *File) Reset() <span class="cov0" title="0">{
        *x = File{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[31]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *File) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*File) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *File) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[31]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use File.ProtoReflect.Descriptor instead.
func (*File) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{31}
}</span>

func (x *File) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *File) GetFileName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *File) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *File) GetCreatedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *File) GetFileSize() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetFilesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetFilesRequest) Reset() <span class="cov0" title="0">{
        *x = GetFilesRequest{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[32]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetFilesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetFilesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetFilesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[32]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetFilesRequest.ProtoReflect.Descriptor instead.
func (*GetFilesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{32}
}</span>

type GetFilesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Files []*File `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
}

func (x *GetFilesResponse) Reset() <span class="cov0" title="0">{
        *x = GetFilesResponse{}
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[33]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetFilesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetFilesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetFilesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_gophkeeper_proto_msgTypes[33]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetFilesResponse.ProtoReflect.Descriptor instead.
func (*GetFilesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_gophkeeper_proto_rawDescGZIP(), []int{33}
}</span>

func (x *GetFilesResponse) GetFiles() []*File <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Files
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_proto_gophkeeper_proto protoreflect.FileDescriptor

var file_proto_gophkeeper_proto_rawDesc = []byte{
        0x0a, 0x16, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70,
        0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65,
        0x65, 0x70, 0x65, 0x72, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x22, 0x71, 0x0a, 0x0b, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64,
        0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f,
        0x72, 0x64, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x22, 0x4c, 0x0a, 0x04, 0x4e, 0x6f, 0x74, 0x65, 0x12, 0x0e, 0x0a, 0x02,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04,
        0x74, 0x65, 0x78, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74,
        0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x22, 0x50, 0x0a, 0x13, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73,
        0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a, 0x0b, 0x63, 0x72, 0x65,
        0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17,
        0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x43, 0x72, 0x65, 0x64,
        0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x0b, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74,
        0x69, 0x61, 0x6c, 0x73, 0x22, 0x4d, 0x0a, 0x10, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a,
        0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a, 0x0b, 0x63, 0x72, 0x65, 0x64,
        0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e,
        0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x43, 0x72, 0x65, 0x64, 0x65,
        0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x0b, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69,
        0x61, 0x6c, 0x73, 0x22, 0x29, 0x0a, 0x11, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65,
        0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x56,
        0x0a, 0x19, 0x41, 0x64, 0x64, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74,
        0x69, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a, 0x0b, 0x63,
        0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x17, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x43, 0x72,
        0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x0b, 0x63, 0x72, 0x65, 0x64, 0x65,
        0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x22, 0x1b, 0x0a, 0x19, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65,
        0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x22, 0x57, 0x0a, 0x1a, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72,
        0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x39, 0x0a, 0x0b, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65,
        0x70, 0x65, 0x72, 0x2e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52,
        0x0b, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x22, 0x2a, 0x0a, 0x18,
        0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61,
        0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x22, 0x56, 0x0a, 0x19, 0x47, 0x65, 0x74, 0x55,
        0x73, 0x65, 0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x39, 0x0a, 0x0b, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74,
        0x69, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x67, 0x6f, 0x70,
        0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69,
        0x61, 0x6c, 0x73, 0x52, 0x0b, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73,
        0x22, 0x36, 0x0a, 0x0e, 0x41, 0x64, 0x64, 0x4e, 0x6f, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x24, 0x0a, 0x04, 0x6e, 0x6f, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x10, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x4e, 0x6f,
        0x74, 0x65, 0x52, 0x04, 0x6e, 0x6f, 0x74, 0x65, 0x22, 0x11, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x4e,
        0x6f, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x3a, 0x0a, 0x10, 0x47,
        0x65, 0x74, 0x4e, 0x6f, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x26, 0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10,
        0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x4e, 0x6f, 0x74, 0x65,
        0x52, 0x05, 0x6e, 0x6f, 0x74, 0x65, 0x73, 0x22, 0x20, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x4e, 0x6f,
        0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x22, 0x37, 0x0a, 0x0f, 0x47, 0x65, 0x74,
        0x4e, 0x6f, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x24, 0x0a, 0x04,
        0x6e, 0x6f, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x67, 0x6f, 0x70,
        0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x4e, 0x6f, 0x74, 0x65, 0x52, 0x04, 0x6e, 0x6f,
        0x74, 0x65, 0x22, 0x23, 0x0a, 0x11, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4e, 0x6f, 0x74, 0x65,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x22, 0x27, 0x0a, 0x0b, 0x45, 0x63, 0x68, 0x6f, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x22, 0x28, 0x0a, 0x0c, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x9c, 0x01, 0x0a, 0x08, 0x42,
        0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65,
        0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12,
        0x1e, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x44, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x44, 0x61, 0x74, 0x65, 0x12,
        0x10, 0x0a, 0x03, 0x63, 0x76, 0x76, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x63, 0x76,
        0x76, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3e, 0x0a, 0x12, 0x41, 0x64, 0x64,
        0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x28, 0x0a, 0x04, 0x63, 0x61, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e,
        0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x42, 0x61, 0x6e, 0x6b, 0x43,
        0x61, 0x72, 0x64, 0x52, 0x04, 0x63, 0x61, 0x72, 0x64, 0x22, 0x27, 0x0a, 0x15, 0x52, 0x65, 0x6d,
        0x6f, 0x76, 0x65, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
        0x69, 0x64, 0x22, 0x2e, 0x0a, 0x1c, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x55, 0x73, 0x65, 0x72,
        0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
        0x69, 0x64, 0x22, 0x15, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72,
        0x64, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x42, 0x0a, 0x14, 0x47, 0x65, 0x74,
        0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x2a, 0x0a, 0x05, 0x63, 0x61, 0x72, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x14, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x42, 0x61,
        0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x52, 0x05, 0x63, 0x61, 0x72, 0x64, 0x73, 0x22, 0x24, 0x0a,
        0x12, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x02, 0x69, 0x64, 0x22, 0x3f, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61,
        0x72, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x04, 0x63, 0x61,
        0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b,
        0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x52, 0x04,
        0x63, 0x61, 0x72, 0x64, 0x22, 0x85, 0x01, 0x0a, 0x11, 0x46, 0x69, 0x6c, 0x65, 0x55, 0x70, 0x6c,
        0x6f, 0x61, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69,
        0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66,
        0x69, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x12, 0x20, 0x0a,
        0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12,
        0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x03, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x22, 0x30, 0x0a, 0x11,
        0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x4e,
        0x0a, 0x12, 0x46, 0x69, 0x6c, 0x65, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x4e, 0x61, 0x6d,
        0x65, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x22, 0x32,
        0x0a, 0x13, 0x46, 0x69, 0x6c, 0x65, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x4e, 0x61,
        0x6d, 0x65, 0x22, 0x87, 0x01, 0x0a, 0x14, 0x46, 0x69, 0x6c, 0x65, 0x44, 0x6f, 0x77, 0x6e, 0x6c,
        0x6f, 0x61, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x63,
        0x68, 0x75, 0x6e, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x63, 0x68, 0x75, 0x6e,
        0x6b, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x1a,
        0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x91, 0x01, 0x0a,
        0x04, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x4e, 0x61,
        0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f,
        0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x41, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65,
        0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x53, 0x69, 0x7a, 0x65,
        0x22, 0x11, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x22, 0x3a, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x26, 0x0a, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65,
        0x70, 0x65, 0x72, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x32,
        0xbf, 0x0b, 0x0a, 0x0a, 0x47, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x12, 0x47,
        0x0a, 0x0c, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1f,
        0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x52, 0x65, 0x67, 0x69,
        0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x48, 0x0a, 0x09, 0x41, 0x75, 0x74, 0x68, 0x6f,
        0x72, 0x69, 0x7a, 0x65, 0x12, 0x1c, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65,
        0x72, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e,
        0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x39, 0x0a, 0x04, 0x45, 0x63, 0x68, 0x6f, 0x12, 0x17, 0x2e, 0x67, 0x6f, 0x70, 0x68,
        0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x18, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e,
        0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x45, 0x0a, 0x0b,
        0x41, 0x64, 0x64, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x12, 0x1e, 0x2e, 0x67, 0x6f,
        0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x41, 0x64, 0x64, 0x42, 0x61, 0x6e, 0x6b,
        0x43, 0x61, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x12, 0x4b, 0x0a, 0x0e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x42, 0x61, 0x6e,
        0x6b, 0x43, 0x61, 0x72, 0x64, 0x12, 0x21, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70,
        0x65, 0x72, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72,
        0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,
        0x12, 0x51, 0x0a, 0x0c, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x73,
        0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x47, 0x65,
        0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x20, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x47,
        0x65, 0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x4e, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61,
        0x72, 0x64, 0x12, 0x1e, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e,
        0x47, 0x65, 0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e,
        0x47, 0x65, 0x74, 0x42, 0x61, 0x6e, 0x6b, 0x43, 0x61, 0x72, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x53, 0x0a, 0x12, 0x41, 0x64, 0x64, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72,
        0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x12, 0x25, 0x2e, 0x67, 0x6f, 0x70, 0x68,
        0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x41, 0x64, 0x64, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72,
        0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x63, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x55,
        0x73, 0x65, 0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x12, 0x25,
        0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x55,
        0x73, 0x65, 0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70,
        0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e,
        0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x60, 0x0a,
        0x11, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69,
        0x61, 0x6c, 0x12, 0x24, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e,
        0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61,
        0x6c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b,
        0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72, 0x65,
        0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x59, 0x0a, 0x15, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x55, 0x73, 0x65, 0x72, 0x43, 0x72, 0x65,
        0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x12, 0x28, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b,
        0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x55, 0x73, 0x65, 0x72,
        0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x3d, 0x0a, 0x07, 0x41, 0x64,
        0x64, 0x4e, 0x6f, 0x74, 0x65, 0x12, 0x1a, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70,
        0x65, 0x72, 0x2e, 0x41, 0x64, 0x64, 0x4e, 0x6f, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x45, 0x0a, 0x08, 0x47, 0x65, 0x74,
        0x4e, 0x6f, 0x74, 0x65, 0x73, 0x12, 0x1b, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70,
        0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e,
        0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x42, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x65, 0x12, 0x1a, 0x2e, 0x67, 0x6f,
        0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x65,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65,
        0x65, 0x70, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x43, 0x0a, 0x0a, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4e, 0x6f,
        0x74, 0x65, 0x12, 0x1d, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e,
        0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x4e, 0x6f, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x49, 0x0a, 0x06, 0x55, 0x70, 0x6c,
        0x6f, 0x61, 0x64, 0x12, 0x1d, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72,
        0x2e, 0x46, 0x69, 0x6c, 0x65, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e,
        0x46, 0x69, 0x6c, 0x65, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x28, 0x01, 0x12, 0x4f, 0x0a, 0x08, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64,
        0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x46, 0x69,
        0x6c, 0x65, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x20, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x46,
        0x69, 0x6c, 0x65, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x30, 0x01, 0x12, 0x43, 0x0a, 0x0a, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x46,
        0x69, 0x6c, 0x65, 0x12, 0x1d, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72,
        0x2e, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x45, 0x0a, 0x08, 0x47, 0x65,
        0x74, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x1b, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65,
        0x70, 0x65, 0x72, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72,
        0x2e, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x42, 0x12, 0x5a, 0x10, 0x67, 0x6f, 0x70, 0x68, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2f,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_proto_gophkeeper_proto_rawDescOnce sync.Once
        file_proto_gophkeeper_proto_rawDescData = file_proto_gophkeeper_proto_rawDesc
)

func file_proto_gophkeeper_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_gophkeeper_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_gophkeeper_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_gophkeeper_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_gophkeeper_proto_rawDescData</span>
}

var file_proto_gophkeeper_proto_msgTypes = make([]protoimpl.MessageInfo, 34)
var file_proto_gophkeeper_proto_goTypes = []any{
        (*Credentials)(nil),                  // 0: gophkeeper.Credentials
        (*Note)(nil),                         // 1: gophkeeper.Note
        (*RegisterUserRequest)(nil),          // 2: gophkeeper.RegisterUserRequest
        (*AuthorizeRequest)(nil),             // 3: gophkeeper.AuthorizeRequest
        (*AuthorizeResponse)(nil),            // 4: gophkeeper.AuthorizeResponse
        (*AddUserCredentialsRequest)(nil),    // 5: gophkeeper.AddUserCredentialsRequest
        (*GetUserCredentialsRequest)(nil),    // 6: gophkeeper.GetUserCredentialsRequest
        (*GetUserCredentialsResponse)(nil),   // 7: gophkeeper.GetUserCredentialsResponse
        (*GetUserCredentialRequest)(nil),     // 8: gophkeeper.GetUserCredentialRequest
        (*GetUserCredentialResponse)(nil),    // 9: gophkeeper.GetUserCredentialResponse
        (*AddNoteRequest)(nil),               // 10: gophkeeper.AddNoteRequest
        (*GetNotesRequest)(nil),              // 11: gophkeeper.GetNotesRequest
        (*GetNotesResponse)(nil),             // 12: gophkeeper.GetNotesResponse
        (*GetNoteRequest)(nil),               // 13: gophkeeper.GetNoteRequest
        (*GetNoteResponse)(nil),              // 14: gophkeeper.GetNoteResponse
        (*RemoveNoteRequest)(nil),            // 15: gophkeeper.RemoveNoteRequest
        (*EchoRequest)(nil),                  // 16: gophkeeper.EchoRequest
        (*EchoResponse)(nil),                 // 17: gophkeeper.EchoResponse
        (*BankCard)(nil),                     // 18: gophkeeper.BankCard
        (*AddBankCardRequest)(nil),           // 19: gophkeeper.AddBankCardRequest
        (*RemoveBankCardRequest)(nil),        // 20: gophkeeper.RemoveBankCardRequest
        (*RemoveUserCredentialsRequest)(nil), // 21: gophkeeper.RemoveUserCredentialsRequest
        (*GetBankCardsRequest)(nil),          // 22: gophkeeper.GetBankCardsRequest
        (*GetBankCardsResponse)(nil),         // 23: gophkeeper.GetBankCardsResponse
        (*GetBankCardRequest)(nil),           // 24: gophkeeper.GetBankCardRequest
        (*GetBankCardResponse)(nil),          // 25: gophkeeper.GetBankCardResponse
        (*FileUploadRequest)(nil),            // 26: gophkeeper.FileUploadRequest
        (*FileRemoveRequest)(nil),            // 27: gophkeeper.FileRemoveRequest
        (*FileUploadResponse)(nil),           // 28: gophkeeper.FileUploadResponse
        (*FileDownloadRequest)(nil),          // 29: gophkeeper.FileDownloadRequest
        (*FileDownloadResponse)(nil),         // 30: gophkeeper.FileDownloadResponse
        (*File)(nil),                         // 31: gophkeeper.File
        (*GetFilesRequest)(nil),              // 32: gophkeeper.GetFilesRequest
        (*GetFilesResponse)(nil),             // 33: gophkeeper.GetFilesResponse
        (*emptypb.Empty)(nil),                // 34: google.protobuf.Empty
}
var file_proto_gophkeeper_proto_depIdxs = []int32{
        0,  // 0: gophkeeper.RegisterUserRequest.credentials:type_name -&gt; gophkeeper.Credentials
        0,  // 1: gophkeeper.AuthorizeRequest.credentials:type_name -&gt; gophkeeper.Credentials
        0,  // 2: gophkeeper.AddUserCredentialsRequest.credentials:type_name -&gt; gophkeeper.Credentials
        0,  // 3: gophkeeper.GetUserCredentialsResponse.credentials:type_name -&gt; gophkeeper.Credentials
        0,  // 4: gophkeeper.GetUserCredentialResponse.credentials:type_name -&gt; gophkeeper.Credentials
        1,  // 5: gophkeeper.AddNoteRequest.note:type_name -&gt; gophkeeper.Note
        1,  // 6: gophkeeper.GetNotesResponse.notes:type_name -&gt; gophkeeper.Note
        1,  // 7: gophkeeper.GetNoteResponse.note:type_name -&gt; gophkeeper.Note
        18, // 8: gophkeeper.AddBankCardRequest.card:type_name -&gt; gophkeeper.BankCard
        18, // 9: gophkeeper.GetBankCardsResponse.cards:type_name -&gt; gophkeeper.BankCard
        18, // 10: gophkeeper.GetBankCardResponse.card:type_name -&gt; gophkeeper.BankCard
        31, // 11: gophkeeper.GetFilesResponse.files:type_name -&gt; gophkeeper.File
        2,  // 12: gophkeeper.Gophkeeper.RegisterUser:input_type -&gt; gophkeeper.RegisterUserRequest
        3,  // 13: gophkeeper.Gophkeeper.Authorize:input_type -&gt; gophkeeper.AuthorizeRequest
        16, // 14: gophkeeper.Gophkeeper.Echo:input_type -&gt; gophkeeper.EchoRequest
        19, // 15: gophkeeper.Gophkeeper.AddBankCard:input_type -&gt; gophkeeper.AddBankCardRequest
        20, // 16: gophkeeper.Gophkeeper.RemoveBankCard:input_type -&gt; gophkeeper.RemoveBankCardRequest
        22, // 17: gophkeeper.Gophkeeper.GetBankCards:input_type -&gt; gophkeeper.GetBankCardsRequest
        24, // 18: gophkeeper.Gophkeeper.GetBankCard:input_type -&gt; gophkeeper.GetBankCardRequest
        5,  // 19: gophkeeper.Gophkeeper.AddUserCredentials:input_type -&gt; gophkeeper.AddUserCredentialsRequest
        6,  // 20: gophkeeper.Gophkeeper.GetUserCredentials:input_type -&gt; gophkeeper.GetUserCredentialsRequest
        8,  // 21: gophkeeper.Gophkeeper.GetUserCredential:input_type -&gt; gophkeeper.GetUserCredentialRequest
        21, // 22: gophkeeper.Gophkeeper.RemoveUserCredentials:input_type -&gt; gophkeeper.RemoveUserCredentialsRequest
        10, // 23: gophkeeper.Gophkeeper.AddNote:input_type -&gt; gophkeeper.AddNoteRequest
        11, // 24: gophkeeper.Gophkeeper.GetNotes:input_type -&gt; gophkeeper.GetNotesRequest
        13, // 25: gophkeeper.Gophkeeper.GetNote:input_type -&gt; gophkeeper.GetNoteRequest
        15, // 26: gophkeeper.Gophkeeper.RemoveNote:input_type -&gt; gophkeeper.RemoveNoteRequest
        26, // 27: gophkeeper.Gophkeeper.Upload:input_type -&gt; gophkeeper.FileUploadRequest
        29, // 28: gophkeeper.Gophkeeper.Download:input_type -&gt; gophkeeper.FileDownloadRequest
        27, // 29: gophkeeper.Gophkeeper.RemoveFile:input_type -&gt; gophkeeper.FileRemoveRequest
        32, // 30: gophkeeper.Gophkeeper.GetFiles:input_type -&gt; gophkeeper.GetFilesRequest
        34, // 31: gophkeeper.Gophkeeper.RegisterUser:output_type -&gt; google.protobuf.Empty
        4,  // 32: gophkeeper.Gophkeeper.Authorize:output_type -&gt; gophkeeper.AuthorizeResponse
        17, // 33: gophkeeper.Gophkeeper.Echo:output_type -&gt; gophkeeper.EchoResponse
        34, // 34: gophkeeper.Gophkeeper.AddBankCard:output_type -&gt; google.protobuf.Empty
        34, // 35: gophkeeper.Gophkeeper.RemoveBankCard:output_type -&gt; google.protobuf.Empty
        23, // 36: gophkeeper.Gophkeeper.GetBankCards:output_type -&gt; gophkeeper.GetBankCardsResponse
        25, // 37: gophkeeper.Gophkeeper.GetBankCard:output_type -&gt; gophkeeper.GetBankCardResponse
        34, // 38: gophkeeper.Gophkeeper.AddUserCredentials:output_type -&gt; google.protobuf.Empty
        7,  // 39: gophkeeper.Gophkeeper.GetUserCredentials:output_type -&gt; gophkeeper.GetUserCredentialsResponse
        9,  // 40: gophkeeper.Gophkeeper.GetUserCredential:output_type -&gt; gophkeeper.GetUserCredentialResponse
        34, // 41: gophkeeper.Gophkeeper.RemoveUserCredentials:output_type -&gt; google.protobuf.Empty
        34, // 42: gophkeeper.Gophkeeper.AddNote:output_type -&gt; google.protobuf.Empty
        12, // 43: gophkeeper.Gophkeeper.GetNotes:output_type -&gt; gophkeeper.GetNotesResponse
        14, // 44: gophkeeper.Gophkeeper.GetNote:output_type -&gt; gophkeeper.GetNoteResponse
        34, // 45: gophkeeper.Gophkeeper.RemoveNote:output_type -&gt; google.protobuf.Empty
        28, // 46: gophkeeper.Gophkeeper.Upload:output_type -&gt; gophkeeper.FileUploadResponse
        30, // 47: gophkeeper.Gophkeeper.Download:output_type -&gt; gophkeeper.FileDownloadResponse
        34, // 48: gophkeeper.Gophkeeper.RemoveFile:output_type -&gt; google.protobuf.Empty
        33, // 49: gophkeeper.Gophkeeper.GetFiles:output_type -&gt; gophkeeper.GetFilesResponse
        31, // [31:50] is the sub-list for method output_type
        12, // [12:31] is the sub-list for method input_type
        12, // [12:12] is the sub-list for extension type_name
        12, // [12:12] is the sub-list for extension extendee
        0,  // [0:12] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_gophkeeper_proto_init() }</span>
func file_proto_gophkeeper_proto_init() <span class="cov8" title="1">{
        if File_proto_gophkeeper_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_gophkeeper_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   34,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_gophkeeper_proto_goTypes,
                DependencyIndexes: file_proto_gophkeeper_proto_depIdxs,
                MessageInfos:      file_proto_gophkeeper_proto_msgTypes,
        }.Build()
        File_proto_gophkeeper_proto = out.File
        file_proto_gophkeeper_proto_rawDesc = nil
        file_proto_gophkeeper_proto_goTypes = nil
        file_proto_gophkeeper_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: proto/gophkeeper.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Gophkeeper_RegisterUser_FullMethodName          = "/gophkeeper.Gophkeeper/RegisterUser"
        Gophkeeper_Authorize_FullMethodName             = "/gophkeeper.Gophkeeper/Authorize"
        Gophkeeper_Echo_FullMethodName                  = "/gophkeeper.Gophkeeper/Echo"
        Gophkeeper_AddBankCard_FullMethodName           = "/gophkeeper.Gophkeeper/AddBankCard"
        Gophkeeper_RemoveBankCard_FullMethodName        = "/gophkeeper.Gophkeeper/RemoveBankCard"
        Gophkeeper_GetBankCards_FullMethodName          = "/gophkeeper.Gophkeeper/GetBankCards"
        Gophkeeper_GetBankCard_FullMethodName           = "/gophkeeper.Gophkeeper/GetBankCard"
        Gophkeeper_AddUserCredentials_FullMethodName    = "/gophkeeper.Gophkeeper/AddUserCredentials"
        Gophkeeper_GetUserCredentials_FullMethodName    = "/gophkeeper.Gophkeeper/GetUserCredentials"
        Gophkeeper_GetUserCredential_FullMethodName     = "/gophkeeper.Gophkeeper/GetUserCredential"
        Gophkeeper_RemoveUserCredentials_FullMethodName = "/gophkeeper.Gophkeeper/RemoveUserCredentials"
        Gophkeeper_AddNote_FullMethodName               = "/gophkeeper.Gophkeeper/AddNote"
        Gophkeeper_GetNotes_FullMethodName              = "/gophkeeper.Gophkeeper/GetNotes"
        Gophkeeper_GetNote_FullMethodName               = "/gophkeeper.Gophkeeper/GetNote"
        Gophkeeper_RemoveNote_FullMethodName            = "/gophkeeper.Gophkeeper/RemoveNote"
        Gophkeeper_Upload_FullMethodName                = "/gophkeeper.Gophkeeper/Upload"
        Gophkeeper_Download_FullMethodName              = "/gophkeeper.Gophkeeper/Download"
        Gophkeeper_RemoveFile_FullMethodName            = "/gophkeeper.Gophkeeper/RemoveFile"
        Gophkeeper_GetFiles_FullMethodName              = "/gophkeeper.Gophkeeper/GetFiles"
)

// GophkeeperClient is the client API for Gophkeeper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GophkeeperClient interface {
        RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        Authorize(ctx context.Context, in *AuthorizeRequest, opts ...grpc.CallOption) (*AuthorizeResponse, error)
        Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
        AddBankCard(ctx context.Context, in *AddBankCardRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        RemoveBankCard(ctx context.Context, in *RemoveBankCardRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        GetBankCards(ctx context.Context, in *GetBankCardsRequest, opts ...grpc.CallOption) (*GetBankCardsResponse, error)
        GetBankCard(ctx context.Context, in *GetBankCardRequest, opts ...grpc.CallOption) (*GetBankCardResponse, error)
        AddUserCredentials(ctx context.Context, in *AddUserCredentialsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        GetUserCredentials(ctx context.Context, in *GetUserCredentialsRequest, opts ...grpc.CallOption) (*GetUserCredentialsResponse, error)
        GetUserCredential(ctx context.Context, in *GetUserCredentialRequest, opts ...grpc.CallOption) (*GetUserCredentialResponse, error)
        RemoveUserCredentials(ctx context.Context, in *RemoveUserCredentialsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        AddNote(ctx context.Context, in *AddNoteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        GetNotes(ctx context.Context, in *GetNotesRequest, opts ...grpc.CallOption) (*GetNotesResponse, error)
        GetNote(ctx context.Context, in *GetNoteRequest, opts ...grpc.CallOption) (*GetNoteResponse, error)
        RemoveNote(ctx context.Context, in *RemoveNoteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        Upload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileUploadRequest, FileUploadResponse], error)
        Download(ctx context.Context, in *FileDownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileDownloadResponse], error)
        RemoveFile(ctx context.Context, in *FileRemoveRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        GetFiles(ctx context.Context, in *GetFilesRequest, opts ...grpc.CallOption) (*GetFilesResponse, error)
}

type gophkeeperClient struct {
        cc grpc.ClientConnInterface
}

func NewGophkeeperClient(cc grpc.ClientConnInterface) GophkeeperClient <span class="cov0" title="0">{
        return &amp;gophkeeperClient{cc}
}</span>

func (c *gophkeeperClient) RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Gophkeeper_RegisterUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) Authorize(ctx context.Context, in *AuthorizeRequest, opts ...grpc.CallOption) (*AuthorizeResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AuthorizeResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_Authorize_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(EchoResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_Echo_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) AddBankCard(ctx context.Context, in *AddBankCardRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Gophkeeper_AddBankCard_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) RemoveBankCard(ctx context.Context, in *RemoveBankCardRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Gophkeeper_RemoveBankCard_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) GetBankCards(ctx context.Context, in *GetBankCardsRequest, opts ...grpc.CallOption) (*GetBankCardsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetBankCardsResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_GetBankCards_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) GetBankCard(ctx context.Context, in *GetBankCardRequest, opts ...grpc.CallOption) (*GetBankCardResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetBankCardResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_GetBankCard_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) AddUserCredentials(ctx context.Context, in *AddUserCredentialsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Gophkeeper_AddUserCredentials_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) GetUserCredentials(ctx context.Context, in *GetUserCredentialsRequest, opts ...grpc.CallOption) (*GetUserCredentialsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserCredentialsResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_GetUserCredentials_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) GetUserCredential(ctx context.Context, in *GetUserCredentialRequest, opts ...grpc.CallOption) (*GetUserCredentialResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserCredentialResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_GetUserCredential_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) RemoveUserCredentials(ctx context.Context, in *RemoveUserCredentialsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Gophkeeper_RemoveUserCredentials_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) AddNote(ctx context.Context, in *AddNoteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Gophkeeper_AddNote_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) GetNotes(ctx context.Context, in *GetNotesRequest, opts ...grpc.CallOption) (*GetNotesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetNotesResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_GetNotes_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) GetNote(ctx context.Context, in *GetNoteRequest, opts ...grpc.CallOption) (*GetNoteResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetNoteResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_GetNote_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) RemoveNote(ctx context.Context, in *RemoveNoteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Gophkeeper_RemoveNote_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) Upload(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileUploadRequest, FileUploadResponse], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;Gophkeeper_ServiceDesc.Streams[0], Gophkeeper_Upload_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[FileUploadRequest, FileUploadResponse]{ClientStream: stream}
        return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Gophkeeper_UploadClient = grpc.ClientStreamingClient[FileUploadRequest, FileUploadResponse]

func (c *gophkeeperClient) Download(ctx context.Context, in *FileDownloadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileDownloadResponse], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;Gophkeeper_ServiceDesc.Streams[1], Gophkeeper_Download_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[FileDownloadRequest, FileDownloadResponse]{ClientStream: stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Gophkeeper_DownloadClient = grpc.ServerStreamingClient[FileDownloadResponse]

func (c *gophkeeperClient) RemoveFile(ctx context.Context, in *FileRemoveRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, Gophkeeper_RemoveFile_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *gophkeeperClient) GetFiles(ctx context.Context, in *GetFilesRequest, opts ...grpc.CallOption) (*GetFilesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetFilesResponse)
        err := c.cc.Invoke(ctx, Gophkeeper_GetFiles_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// GophkeeperServer is the server API for Gophkeeper service.
// All implementations must embed UnimplementedGophkeeperServer
// for forward compatibility.
type GophkeeperServer interface {
        RegisterUser(context.Context, *RegisterUserRequest) (*emptypb.Empty, error)
        Authorize(context.Context, *AuthorizeRequest) (*AuthorizeResponse, error)
        Echo(context.Context, *EchoRequest) (*EchoResponse, error)
        AddBankCard(context.Context, *AddBankCardRequest) (*emptypb.Empty, error)
        RemoveBankCard(context.Context, *RemoveBankCardRequest) (*emptypb.Empty, error)
        GetBankCards(context.Context, *GetBankCardsRequest) (*GetBankCardsResponse, error)
        GetBankCard(context.Context, *GetBankCardRequest) (*GetBankCardResponse, error)
        AddUserCredentials(context.Context, *AddUserCredentialsRequest) (*emptypb.Empty, error)
        GetUserCredentials(context.Context, *GetUserCredentialsRequest) (*GetUserCredentialsResponse, error)
        GetUserCredential(context.Context, *GetUserCredentialRequest) (*GetUserCredentialResponse, error)
        RemoveUserCredentials(context.Context, *RemoveUserCredentialsRequest) (*emptypb.Empty, error)
        AddNote(context.Context, *AddNoteRequest) (*emptypb.Empty, error)
        GetNotes(context.Context, *GetNotesRequest) (*GetNotesResponse, error)
        GetNote(context.Context, *GetNoteRequest) (*GetNoteResponse, error)
        RemoveNote(context.Context, *RemoveNoteRequest) (*emptypb.Empty, error)
        Upload(grpc.ClientStreamingServer[FileUploadRequest, FileUploadResponse]) error
        Download(*FileDownloadRequest, grpc.ServerStreamingServer[FileDownloadResponse]) error
        RemoveFile(context.Context, *FileRemoveRequest) (*emptypb.Empty, error)
        GetFiles(context.Context, *GetFilesRequest) (*GetFilesResponse, error)
        mustEmbedUnimplementedGophkeeperServer()
}

// UnimplementedGophkeeperServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGophkeeperServer struct{}

func (UnimplementedGophkeeperServer) RegisterUser(context.Context, *RegisterUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}</span>
func (UnimplementedGophkeeperServer) Authorize(context.Context, *AuthorizeRequest) (*AuthorizeResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Authorize not implemented")
}</span>
func (UnimplementedGophkeeperServer) Echo(context.Context, *EchoRequest) (*EchoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Echo not implemented")
}</span>
func (UnimplementedGophkeeperServer) AddBankCard(context.Context, *AddBankCardRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddBankCard not implemented")
}</span>
func (UnimplementedGophkeeperServer) RemoveBankCard(context.Context, *RemoveBankCardRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveBankCard not implemented")
}</span>
func (UnimplementedGophkeeperServer) GetBankCards(context.Context, *GetBankCardsRequest) (*GetBankCardsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetBankCards not implemented")
}</span>
func (UnimplementedGophkeeperServer) GetBankCard(context.Context, *GetBankCardRequest) (*GetBankCardResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetBankCard not implemented")
}</span>
func (UnimplementedGophkeeperServer) AddUserCredentials(context.Context, *AddUserCredentialsRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddUserCredentials not implemented")
}</span>
func (UnimplementedGophkeeperServer) GetUserCredentials(context.Context, *GetUserCredentialsRequest) (*GetUserCredentialsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserCredentials not implemented")
}</span>
func (UnimplementedGophkeeperServer) GetUserCredential(context.Context, *GetUserCredentialRequest) (*GetUserCredentialResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserCredential not implemented")
}</span>
func (UnimplementedGophkeeperServer) RemoveUserCredentials(context.Context, *RemoveUserCredentialsRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveUserCredentials not implemented")
}</span>
func (UnimplementedGophkeeperServer) AddNote(context.Context, *AddNoteRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddNote not implemented")
}</span>
func (UnimplementedGophkeeperServer) GetNotes(context.Context, *GetNotesRequest) (*GetNotesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetNotes not implemented")
}</span>
func (UnimplementedGophkeeperServer) GetNote(context.Context, *GetNoteRequest) (*GetNoteResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetNote not implemented")
}</span>
func (UnimplementedGophkeeperServer) RemoveNote(context.Context, *RemoveNoteRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveNote not implemented")
}</span>
func (UnimplementedGophkeeperServer) Upload(grpc.ClientStreamingServer[FileUploadRequest, FileUploadResponse]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method Upload not implemented")
}</span>
func (UnimplementedGophkeeperServer) Download(*FileDownloadRequest, grpc.ServerStreamingServer[FileDownloadResponse]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method Download not implemented")
}</span>
func (UnimplementedGophkeeperServer) RemoveFile(context.Context, *FileRemoveRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveFile not implemented")
}</span>
func (UnimplementedGophkeeperServer) GetFiles(context.Context, *GetFilesRequest) (*GetFilesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetFiles not implemented")
}</span>
func (UnimplementedGophkeeperServer) mustEmbedUnimplementedGophkeeperServer() {<span class="cov0" title="0">}</span>
func (UnimplementedGophkeeperServer) testEmbeddedByValue()                    {<span class="cov0" title="0">}</span>

// UnsafeGophkeeperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GophkeeperServer will
// result in compilation errors.
type UnsafeGophkeeperServer interface {
        mustEmbedUnimplementedGophkeeperServer()
}

func RegisterGophkeeperServer(s grpc.ServiceRegistrar, srv GophkeeperServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedGophkeeperServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Gophkeeper_ServiceDesc, srv)</span>
}

func _Gophkeeper_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RegisterUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_RegisterUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RegisterUser(ctx, req.(*RegisterUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_Authorize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AuthorizeRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).Authorize(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_Authorize_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).Authorize(ctx, req.(*AuthorizeRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(EchoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).Echo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_Echo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).Echo(ctx, req.(*EchoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_AddBankCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddBankCardRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).AddBankCard(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_AddBankCard_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).AddBankCard(ctx, req.(*AddBankCardRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_RemoveBankCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RemoveBankCardRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RemoveBankCard(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_RemoveBankCard_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RemoveBankCard(ctx, req.(*RemoveBankCardRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_GetBankCards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetBankCardsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetBankCards(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_GetBankCards_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetBankCards(ctx, req.(*GetBankCardsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_GetBankCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetBankCardRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetBankCard(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_GetBankCard_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetBankCard(ctx, req.(*GetBankCardRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_AddUserCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddUserCredentialsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).AddUserCredentials(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_AddUserCredentials_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).AddUserCredentials(ctx, req.(*AddUserCredentialsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_GetUserCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserCredentialsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetUserCredentials(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_GetUserCredentials_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetUserCredentials(ctx, req.(*GetUserCredentialsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_GetUserCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserCredentialRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetUserCredential(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_GetUserCredential_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetUserCredential(ctx, req.(*GetUserCredentialRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_RemoveUserCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RemoveUserCredentialsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RemoveUserCredentials(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_RemoveUserCredentials_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RemoveUserCredentials(ctx, req.(*RemoveUserCredentialsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_AddNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddNoteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).AddNote(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_AddNote_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).AddNote(ctx, req.(*AddNoteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_GetNotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetNotesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetNotes(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_GetNotes_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetNotes(ctx, req.(*GetNotesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_GetNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetNoteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetNote(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_GetNote_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetNote(ctx, req.(*GetNoteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_RemoveNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RemoveNoteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RemoveNote(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_RemoveNote_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RemoveNote(ctx, req.(*RemoveNoteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_Upload_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(GophkeeperServer).Upload(&amp;grpc.GenericServerStream[FileUploadRequest, FileUploadResponse]{ServerStream: stream})
}</span>

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Gophkeeper_UploadServer = grpc.ClientStreamingServer[FileUploadRequest, FileUploadResponse]

func _Gophkeeper_Download_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(FileDownloadRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(GophkeeperServer).Download(m, &amp;grpc.GenericServerStream[FileDownloadRequest, FileDownloadResponse]{ServerStream: stream})</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Gophkeeper_DownloadServer = grpc.ServerStreamingServer[FileDownloadResponse]

func _Gophkeeper_RemoveFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(FileRemoveRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RemoveFile(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_RemoveFile_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).RemoveFile(ctx, req.(*FileRemoveRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Gophkeeper_GetFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetFilesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetFiles(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Gophkeeper_GetFiles_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GophkeeperServer).GetFiles(ctx, req.(*GetFilesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Gophkeeper_ServiceDesc is the grpc.ServiceDesc for Gophkeeper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gophkeeper_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "gophkeeper.Gophkeeper",
        HandlerType: (*GophkeeperServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "RegisterUser",
                        Handler:    _Gophkeeper_RegisterUser_Handler,
                },
                {
                        MethodName: "Authorize",
                        Handler:    _Gophkeeper_Authorize_Handler,
                },
                {
                        MethodName: "Echo",
                        Handler:    _Gophkeeper_Echo_Handler,
                },
                {
                        MethodName: "AddBankCard",
                        Handler:    _Gophkeeper_AddBankCard_Handler,
                },
                {
                        MethodName: "RemoveBankCard",
                        Handler:    _Gophkeeper_RemoveBankCard_Handler,
                },
                {
                        MethodName: "GetBankCards",
                        Handler:    _Gophkeeper_GetBankCards_Handler,
                },
                {
                        MethodName: "GetBankCard",
                        Handler:    _Gophkeeper_GetBankCard_Handler,
                },
                {
                        MethodName: "AddUserCredentials",
                        Handler:    _Gophkeeper_AddUserCredentials_Handler,
                },
                {
                        MethodName: "GetUserCredentials",
                        Handler:    _Gophkeeper_GetUserCredentials_Handler,
                },
                {
                        MethodName: "GetUserCredential",
                        Handler:    _Gophkeeper_GetUserCredential_Handler,
                },
                {
                        MethodName: "RemoveUserCredentials",
                        Handler:    _Gophkeeper_RemoveUserCredentials_Handler,
                },
                {
                        MethodName: "AddNote",
                        Handler:    _Gophkeeper_AddNote_Handler,
                },
                {
                        MethodName: "GetNotes",
                        Handler:    _Gophkeeper_GetNotes_Handler,
                },
                {
                        MethodName: "GetNote",
                        Handler:    _Gophkeeper_GetNote_Handler,
                },
                {
                        MethodName: "RemoveNote",
                        Handler:    _Gophkeeper_RemoveNote_Handler,
                },
                {
                        MethodName: "RemoveFile",
                        Handler:    _Gophkeeper_RemoveFile_Handler,
                },
                {
                        MethodName: "GetFiles",
                        Handler:    _Gophkeeper_GetFiles_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "Upload",
                        Handler:       _Gophkeeper_Upload_Handler,
                        ClientStreams: true,
                },
                {
                        StreamName:    "Download",
                        Handler:       _Gophkeeper_Download_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "proto/gophkeeper.proto",
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
